/* automatically generated by rust-bindgen 0.59.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const PSA_KEY_ID_INIT: u32 = 0;
pub const PSA_CRYPTO_API_VERSION_MAJOR: u32 = 1;
pub const PSA_CRYPTO_API_VERSION_MINOR: u32 = 0;
pub const PSA_MAC_TRUNCATION_OFFSET: u32 = 16;
pub const PSA_AEAD_TAG_LENGTH_OFFSET: u32 = 16;
pub const PSA_HASH_MAX_SIZE: u32 = 32;
pub const PSA_HMAC_MAX_HASH_BLOCK_SIZE: u32 = 64;
pub const PSA_MAC_MAX_SIZE: u32 = 32;
pub const PSA_AEAD_TAG_MAX_SIZE: u32 = 16;
pub const PSA_VENDOR_RSA_MAX_KEY_BITS: u32 = 4096;
pub const PSA_VENDOR_ECC_MAX_CURVE_BITS: u32 = 521;
pub const PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE: u32 = 128;
pub const PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_NONCE_MAX_SIZE: u32 = 13;
pub const PSA_AEAD_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_IV_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_MAX_KEY_BITS: u32 = 65528;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const CJSON_VERSION_MAJOR: u32 = 1;
pub const CJSON_VERSION_MINOR: u32 = 7;
pub const CJSON_VERSION_PATCH: u32 = 15;
pub const cJSON_Invalid: u32 = 0;
pub const cJSON_False: u32 = 1;
pub const cJSON_True: u32 = 2;
pub const cJSON_NULL: u32 = 4;
pub const cJSON_Number: u32 = 8;
pub const cJSON_String: u32 = 16;
pub const cJSON_Array: u32 = 32;
pub const cJSON_Object: u32 = 64;
pub const cJSON_Raw: u32 = 128;
pub const cJSON_IsReference: u32 = 256;
pub const cJSON_StringIsConst: u32 = 512;
pub const CJSON_NESTING_LIMIT: u32 = 1000;
pub const IOTEX_HASH_LEN: u32 = 32;
pub const IOTEX_BLOCK_SIZE: u32 = 136;
pub const IOTEX_NUM_ROUNDS: u32 = 24;
pub const NANOPB_VERSION: &'static [u8; 17usize] = b"nanopb-0.4.8-dev\0";
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const PB_LITTLE_ENDIAN_8BIT: u32 = 1;
pub const PB_MAX_REQUIRED_FIELDS: u32 = 64;
pub const PB_LTYPE_BOOL: u32 = 0;
pub const PB_LTYPE_VARINT: u32 = 1;
pub const PB_LTYPE_UVARINT: u32 = 2;
pub const PB_LTYPE_SVARINT: u32 = 3;
pub const PB_LTYPE_FIXED32: u32 = 4;
pub const PB_LTYPE_FIXED64: u32 = 5;
pub const PB_LTYPE_LAST_PACKABLE: u32 = 5;
pub const PB_LTYPE_BYTES: u32 = 6;
pub const PB_LTYPE_STRING: u32 = 7;
pub const PB_LTYPE_SUBMESSAGE: u32 = 8;
pub const PB_LTYPE_SUBMSG_W_CB: u32 = 9;
pub const PB_LTYPE_EXTENSION: u32 = 10;
pub const PB_LTYPE_FIXED_LENGTH_BYTES: u32 = 11;
pub const PB_LTYPES_COUNT: u32 = 12;
pub const PB_LTYPE_MASK: u32 = 15;
pub const PB_HTYPE_REQUIRED: u32 = 0;
pub const PB_HTYPE_OPTIONAL: u32 = 16;
pub const PB_HTYPE_SINGULAR: u32 = 16;
pub const PB_HTYPE_REPEATED: u32 = 32;
pub const PB_HTYPE_FIXARRAY: u32 = 32;
pub const PB_HTYPE_ONEOF: u32 = 48;
pub const PB_HTYPE_MASK: u32 = 48;
pub const PB_ATYPE_STATIC: u32 = 0;
pub const PB_ATYPE_POINTER: u32 = 128;
pub const PB_ATYPE_CALLBACK: u32 = 64;
pub const PB_ATYPE_MASK: u32 = 192;
pub const PB_PROTO_HEADER_VERSION: u32 = 40;
pub const PB_FI_WIDTH_PB_LTYPE_BOOL: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_BYTES: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_DOUBLE: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_ENUM: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_UENUM: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FIXED32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FIXED64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FLOAT: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_INT32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_INT64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_MESSAGE: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_MSG_W_CB: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_SFIXED32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_SFIXED64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_SINT32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_SINT64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_STRING: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_UINT32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_UINT64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_EXTENSION: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FIXED_LENGTH_BYTES: u32 = 2;
pub const PB_LTYPE_MAP_BOOL: u32 = 0;
pub const PB_LTYPE_MAP_BYTES: u32 = 6;
pub const PB_LTYPE_MAP_DOUBLE: u32 = 5;
pub const PB_LTYPE_MAP_ENUM: u32 = 1;
pub const PB_LTYPE_MAP_UENUM: u32 = 2;
pub const PB_LTYPE_MAP_FIXED32: u32 = 4;
pub const PB_LTYPE_MAP_FIXED64: u32 = 5;
pub const PB_LTYPE_MAP_FLOAT: u32 = 4;
pub const PB_LTYPE_MAP_INT32: u32 = 1;
pub const PB_LTYPE_MAP_INT64: u32 = 1;
pub const PB_LTYPE_MAP_MESSAGE: u32 = 8;
pub const PB_LTYPE_MAP_MSG_W_CB: u32 = 9;
pub const PB_LTYPE_MAP_SFIXED32: u32 = 4;
pub const PB_LTYPE_MAP_SFIXED64: u32 = 5;
pub const PB_LTYPE_MAP_SINT32: u32 = 3;
pub const PB_LTYPE_MAP_SINT64: u32 = 3;
pub const PB_LTYPE_MAP_STRING: u32 = 7;
pub const PB_LTYPE_MAP_UINT32: u32 = 2;
pub const PB_LTYPE_MAP_UINT64: u32 = 2;
pub const PB_LTYPE_MAP_EXTENSION: u32 = 10;
pub const PB_LTYPE_MAP_FIXED_LENGTH_BYTES: u32 = 11;
pub const PB_DECODE_NOINIT: u32 = 1;
pub const PB_DECODE_DELIMITED: u32 = 2;
pub const PB_DECODE_NULLTERMINATED: u32 = 4;
pub const PB_ENCODE_DELIMITED: u32 = 2;
pub const PB_ENCODE_NULLTERMINATED: u32 = 4;
pub const Header_event_type_tag: u32 = 1;
pub const Header_pub_id_tag: u32 = 2;
pub const Header_token_tag: u32 = 3;
pub const Header_pub_time_tag: u32 = 4;
pub const Header_event_id_tag: u32 = 5;
pub const Header_size: u32 = 200;
pub const Confirm_owner_tag: u32 = 1;
pub const Confirm_timestamp_tag: u32 = 2;
pub const Confirm_signature_tag: u32 = 3;
pub const Confirm_channel_tag: u32 = 4;
pub const Confirm_size: u32 = 177;
pub const Payload_ptype_tag: u32 = 1;
pub const Payload_pubkey_tag: u32 = 2;
pub const Payload_sign_tag: u32 = 3;
pub const Payload_mac_tag: u32 = 4;
pub const Payload_dtype_tag: u32 = 5;
pub const Payload_user_tag: u32 = 6;
pub const Payload_pConfirm_tag: u32 = 7;
pub const Payload_size: u32 = 648;
pub const Upload_header_tag: u32 = 1;
pub const Upload_payload_tag: u32 = 2;
pub const Upload_size: u32 = 854;
pub const IOTEX_KEEP_ALIVE: u32 = 60;
pub const IOTEX_MAX_TOPIC_NUM: u32 = 1;
pub const IOTEX_MAX_TOPIC_SIZE: u32 = 64;
pub const IOTEX_MQTT_QOS: u32 = 0;
pub const IOTEX_MAX_TOKEN_SIZE: u32 = 160;
pub const IOTEX_DEV_ACCESS_ERR_SUCCESS: u32 = 0;
pub const IOTEX_DEV_ACCESS_ERR_NO_INIT: i32 = -1;
pub const IOTEX_DEV_ACCESS_ERR_GENERAL: i32 = -2;
pub const IOTEX_DEV_ACCESS_ERR_BAD_INPUT_PARAMETER: i32 = -3;
pub const IOTEX_DEV_ACCESS_ERR_BAD_STATUS: i32 = -4;
pub const IOTEX_DEV_ACCESS_ERR_ALLOCATE_FAIL: i32 = -5;
pub const IOTEX_DEV_ACCESS_ERR_SEND_DATA_FAIL: i32 = -6;
pub const IOTEX_DEV_ACCESS_ERR_LINK_NOT_ESTABLISH: i32 = -7;
pub const IOTEX_DEV_ACCESS_ERR_TIME_FUNC_EMPTY: i32 = -256;
pub const IOTEX_DEV_ACCESS_ERR_SIGN_FUNC_EMPTY: i32 = -257;
pub const IOTEX_DEV_ACCESS_ERR_MQTT_PUB_FUNC_EMPTY: i32 = -258;
pub const IOTEX_DEV_ACCESS_ERR_MQTT_SUB_FUNC_EMPTY: i32 = -259;
pub const IOTEX_DEV_ACCESS_ERR_JSON_FAIL: i32 = -512;
pub const IOTEX_DEVICE_ID_LEN: u32 = 15;
pub const DATA_BUFFER_SIZE: u32 = 500;
pub const IOTEX_WALLET_SIZE: u32 = 160;
pub const IOTEX_DEVICE_ID_SIZE: u32 = 16;
pub const IOTEX_SIGN_VALUE_SIZE: u32 = 68;
pub const IOTEX_DEV_REG_DEBUG_ENABLE: u32 = 1;
pub const IOTEX_DEV_REG_DEBUG_DISABLE: u32 = 0;
pub const DEFAULT_CHANNEL: u32 = 8183;
pub const DEFAULT_UPLOAD_PERIOD: u32 = 300;
pub const IOTEX_PUB_ID_DEFAULT: &'static [u8; 6usize] = b"ESP32\0";
pub const IOTEX_EVENT_ID_DEFAULT: &'static [u8; 6usize] = b"ESP32\0";
pub const IOTEX_WEBSTREAM_STUDIO_COMMUNICATE_TYPE: &'static [u8; 5usize] = b"mqtt\0";
pub const IOTEX_WEBSTREAM_STUDIO_URL: &'static [u8; 34usize] =
    b"devnet-staging-mqtt.w3bstream.com\0";
pub const IOTEX_WEBSTREAM_STUDIO_PORT: &'static [u8; 5usize] = b"1883\0";
pub const IOTEX_WEBSTREAM_STUDIO_ADDRESS: &'static [u8; 46usize] =
    b"mqtt://devnet-staging-mqtt.w3bstream.com:1883\0";
pub const IOTEX_EVENT_TYPE_PUBKEY: &'static [u8; 7usize] = b"PUBKEY\0";
pub const IOTEX_EVENT_TYPE_DEFAULT: &'static [u8; 8usize] = b"DEFAULT\0";
pub const IOTEX_PUB_TIME_TEST_DEFAULT: u64 = 1683868814000;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const JOSE_HEADER_TYPE_ENCRPT_TYPE: &'static [u8; 35usize] =
    b"application/didcomm-encrypted+json\0";
pub const JOSE_HEADER_TYPE_SIGN_TYPE: &'static [u8; 32usize] = b"application/didcomm-signed+json\0";
pub const JOSE_HEADER_TYPE_COMPACT: &'static [u8; 5usize] = b"JOSE\0";
pub const JOSE_HEADER_TYPE_JSON: &'static [u8; 10usize] = b"JOSE+JSON\0";
pub const JOSE_HEADER_TYPE_JWT: &'static [u8; 4usize] = b"JWT\0";
pub const JOSE_JWE_RECIPIENTS_MAX: u32 = 4;
pub const IOTEX_JWK_LIFETIME_VOLATILE: u32 = 0;
pub const IOTEX_JWK_LIFETIME_PERSISTENT: u32 = 1;
pub const DIDS_CONTEXT_NUM_MAX: u32 = 4;
pub const DIDS_ALSO_KNOWN_AS_NUM_MAX: u32 = 4;
pub const DIDS_CONTROLLERS_NUM_MAX: u32 = 4;
pub const DIDS_VERIFICATION_METHOD_NUM_MAX: u32 = 4;
pub const IOTEX_DIDDOC_DEFAULT_CONTEXT: &'static [u8; 29usize] = b"https://www.w3.org/ns/did/v1\0";
pub const IOTEX_DIDDOC_BUILD_PROPERTY_TYPE_CONTEXT: u32 = 65536;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_TYPE_ID: u32 = 131072;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_TYPE_ALSO_KNOWN_AS: u32 = 196608;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_TYPE_CONTROLLER: u32 = 262144;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_TYPE_SERVICE: u32 = 327680;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_TYPE_PROPERTY: u32 = 393216;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_SUB_TYPE_PRIVATE_STRING: u32 = 1;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_SUB_TYPE_PRIVATE_NUM: u32 = 2;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_SUB_TYPE_PRIVATE_BOOL: u32 = 4;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_SUB_TYPE_PRIVATE_JSON: u32 = 8;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_SUB_TYPE_PRIVATE_MASK: u32 = 15;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_MAIN_TYPE_MASK: u32 = 4294901760;
pub const IOTEX_DIDDOC_BUILD_PROPERTY_SUB_TYPE_MASK: u32 = 65535;
pub const IOTEX_DIDDOC_BUILD_VM_MAP_TYPE_ID: u32 = 1;
pub const IOTEX_DIDDOC_BUILD_VM_MAP_TYPE_TYPE: u32 = 2;
pub const IOTEX_DIDDOC_BUILD_VM_MAP_TYPE_CON: u32 = 3;
pub const IOTEX_DIDDOC_BUILD_VM_MAP_TYPE_JWK: u32 = 4;
pub const IOTEX_DIDDOC_BUILD_VM_MAP_TYPE_MULTIBASE: u32 = 5;
pub const IOTEX_DIDDOC_BUILD_VM_MAP_TYPE_BASE58: u32 = 6;
pub const IOTEX_DIDDOC_BUILD_VM_MAP_TYPE_MASK: u32 = 65535;
pub const IOTEX_DIDDOC_BUILD_SERVICE_TYPE_ID: u32 = 1;
pub const IOTEX_DIDDOC_BUILD_SERVICE_TYPE_TYPE: u32 = 2;
pub const IOTEX_DIDDOC_BUILD_SERVICE_TYPE_ENDPOINT: u32 = 3;
pub const IOTEX_DIDDOC_BUILD_SERVICE_TYPE_MASK: u32 = 65535;
pub const IOTEX_DIDDOC_VM_PURPOSE_NAME_VERIFICATION_METHOD: &'static [u8; 19usize] =
    b"verificationMethod\0";
pub const IOTEX_DIDDOC_VM_PURPOSE_NAME_AUTHENTICATION: &'static [u8; 15usize] = b"authentication\0";
pub const IOTEX_DIDDOC_VM_PURPOSE_NAME_ASSERTION_METHOD: &'static [u8; 16usize] =
    b"assertionMethod\0";
pub const IOTEX_DIDDOC_VM_PURPOSE_NAME_KEY_AGREEMENT: &'static [u8; 13usize] = b"keyAgreement\0";
pub const IOTEX_DIDDOC_VM_PURPOSE_NAME_CAPABILITY_INVOCATION: &'static [u8; 21usize] =
    b"capabilityInvocation\0";
pub const IOTEX_DIDDOC_VM_PURPOSE_NAME_CAPABILITY_DELEGATION: &'static [u8; 21usize] =
    b"capabilityDelegation\0";
pub const IOTEX_DIDDOC_VM_PURPOSE_NAME_PUBLIC_KEY: &'static [u8; 10usize] = b"publicKey\0";
pub const IOTEX_DIDDOC_PROPERTY_ID_BUFFER_SIZE: u32 = 64;
pub const IOTEX_DIDDOC_PROPERTY_SERVICE_ID_BUFFER_SIZE: u32 = 64;
pub const IOTEX_VERIFICATION_METHOD_PROPERTY_CON_BUFFER_SIZE: u32 = 64;
pub const IOTEX_VERIFICATION_METHOD_TYPE_VALUE_JSONWEBKEY2020: &'static [u8; 15usize] =
    b"JsonWebKey2020\0";
pub const IOTEX_VERIFICATION_METHOD_TYPE_VALUE_ECDSASECP256K1VERIFICATIONKEY2019:
    &'static [u8; 34usize] = b"EcdsaSecp256k1VerificationKey2019\0";
pub const IOTEX_VERIFICATION_METHOD_TYPE_VALUE_ED25519VEIFICATIONKEY2018: &'static [u8; 27usize] =
    b"Ed25519VerificationKey2018\0";
pub const IOTEX_VERIFICATION_METHOD_TYPE_VALUE_BLS12381G1KEY2020: &'static [u8; 18usize] =
    b"Bls12381G1Key2020\0";
pub const IOTEX_VERIFICATION_METHOD_TYPE_VALUE_BLS12381G2KEY2020: &'static [u8; 18usize] =
    b"Bls12381G2Key2020\0";
pub const IOTEX_VERIFICATION_METHOD_TYPE_VALUE_PGPVERIFICATIONKEY2021: &'static [u8; 23usize] =
    b"PgpVerificationKey2021\0";
pub const IOTEX_VERIFICATION_METHOD_TYPE_VALUE_RSAVERIFICATIONKEY2018: &'static [u8; 23usize] =
    b"RsaVerificationKey2018\0";
pub const DID_METHOD_IO_NAME: &'static [u8; 3usize] = b"io\0";
pub const DID_METHOD_KEY_NAME: &'static [u8; 4usize] = b"key\0";
pub const IOTEX_REGISTRY_MAX: u32 = 4;
pub const IOTEX_CREDENTIALS_V1_CONTEXT: &'static [u8; 39usize] =
    b"https://www.w3.org/2018/credentials/v1\0";
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_CONTEXT: u32 = 16777216;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_ID: u32 = 33554432;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_TYPE: u32 = 50331648;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_CS: u32 = 67108864;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_ISSUER: u32 = 83886080;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_ISSUER_DATE: u32 = 100663296;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_PROOF: u32 = 117440512;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_STATUS: u32 = 134217728;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_TERMOFUSE: u32 = 150994944;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_EVIDENCE: u32 = 167772160;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_SCHEMA: u32 = 184549376;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_RS: u32 = 201326592;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_EXP: u32 = 218103808;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_PROPERTY: u32 = 234881024;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_MIN: u32 = 16777216;
pub const IOTEX_VC_BUILD_PROPERTY_TYPE_MAX: u32 = 234881024;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_PRIVATE_STRING: u32 = 1;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_PRIVATE_NUM: u32 = 2;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_PRIVATE_BOOL: u32 = 4;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_PRIVATE_JSON: u32 = 8;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_ID: u32 = 16;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_TYPE: u32 = 32;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_PRIVATE_MASK: u32 = 15;
pub const IOTEX_VC_BUILD_PROPERTY_MAIN_TYPE_MASK: u32 = 4278190080;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_MASK: u32 = 16777215;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_PROOF_VALID_MASK: u32 = 15;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_CS_VALID_MASK: u32 = 31;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_ISSUER_VALID_MASK: u32 = 31;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_EVIDENCE_VALID_MASK: u32 = 31;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_STATUS_VALID_MASK: u32 = 63;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_TERMOFUSE_VALID_MASK: u32 = 63;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_SCHEMA_VALID_MASK: u32 = 63;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_RS_VALID_MASK: u32 = 63;
pub const IOTEX_VC_BUILD_PROPERTY_SUB_TYPE_PROPERTY_VALID_MASK: u32 = 15;
pub const IOTEX_VC_PROOF_PROPERTY_CONTEXT_NAME: &'static [u8; 9usize] = b"@context\0";
pub const IOTEX_VC_PROOF_PROPERTY_PURPOSE_NAME: &'static [u8; 13usize] = b"proofPurpose\0";
pub const IOTEX_VC_PROOF_PROPERTY_VALUE_NAME: &'static [u8; 11usize] = b"proofValue\0";
pub const IOTEX_VC_PROOF_PROPERTY_CHALLENGE_NAME: &'static [u8; 10usize] = b"challenge\0";
pub const IOTEX_VC_PROOF_PROPERTY_VERIFICATION_METHOD_NAME: &'static [u8; 19usize] =
    b"verificationMethod\0";
pub const IOTEX_VC_PROOF_PROPERTY_CREATED_NAME: &'static [u8; 8usize] = b"created\0";
pub const IOTEX_VC_PROOF_PROPERTY_EXPIRES_NAME: &'static [u8; 8usize] = b"expires\0";
pub const IOTEX_VC_PROOF_PROPERTY_DOMAIN_NAME: &'static [u8; 7usize] = b"domain\0";
pub const IOTEX_VC_PROOF_PROPERTY_NONCE_NAME: &'static [u8; 6usize] = b"nonce\0";
pub const IOTEX_VC_PROOF_PROPERTY_CRYPTOSUITE_NAME: &'static [u8; 12usize] = b"cryptosuite\0";
pub const IOTEX_VC_PROPERTY_ID_BUFFER_SIZE: u32 = 64;
pub const IOTEX_VC_PROPERTY_EXP_DATE_BUFFER_SIZE: u32 = 64;
pub const IOTEX_VC_PROPERTY_ISSUANCE_DATE_BUFFER_SIZE: u32 = 32;
pub const DIDCOMM_SIGN_TYP: &'static [u8; 32usize] = b"application/didcomm-signed+json\0";
pub const PLAINTEXT_TYP: &'static [u8; 31usize] = b"application/didcomm-plain+json\0";
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type psa_status_t = i32;
#[doc = " \\brief Encoding of a key type."]
pub type psa_key_type_t = u16;
#[doc = " The type of PSA elliptic curve family identifiers."]
#[doc = ""]
#[doc = " The curve identifier is required to create an ECC key using the"]
#[doc = " PSA_KEY_TYPE_ECC_KEY_PAIR() or PSA_KEY_TYPE_ECC_PUBLIC_KEY()"]
#[doc = " macros."]
#[doc = ""]
#[doc = " Values defined by this standard will never be in the range 0x80-0xff."]
#[doc = " Vendors who define additional families must use an encoding in this range."]
pub type psa_ecc_family_t = u8;
#[doc = " The type of PSA Diffie-Hellman group family identifiers."]
#[doc = ""]
#[doc = " The group identifier is required to create an Diffie-Hellman key using the"]
#[doc = " PSA_KEY_TYPE_DH_KEY_PAIR() or PSA_KEY_TYPE_DH_PUBLIC_KEY()"]
#[doc = " macros."]
#[doc = ""]
#[doc = " Values defined by this standard will never be in the range 0x80-0xff."]
#[doc = " Vendors who define additional families must use an encoding in this range."]
pub type psa_dh_family_t = u8;
#[doc = " \\brief Encoding of a cryptographic algorithm."]
#[doc = ""]
#[doc = " For algorithms that can be applied to multiple key types, this type"]
#[doc = " does not encode the key type. For example, for symmetric ciphers"]
#[doc = " based on a block cipher, #psa_algorithm_t encodes the block cipher"]
#[doc = " mode and the padding mode while the block cipher itself is encoded"]
#[doc = " via #psa_key_type_t."]
pub type psa_algorithm_t = u32;
#[doc = " Encoding of key lifetimes."]
#[doc = ""]
#[doc = " The lifetime of a key indicates where it is stored and what system actions"]
#[doc = " may create and destroy it."]
#[doc = ""]
#[doc = " Lifetime values have the following structure:"]
#[doc = " - Bits 0-7 (#PSA_KEY_LIFETIME_GET_PERSISTENCE(\\c lifetime)):"]
#[doc = "   persistence level. This value indicates what device management"]
#[doc = "   actions can cause it to be destroyed. In particular, it indicates"]
#[doc = "   whether the key is _volatile_ or _persistent_."]
#[doc = "   See ::psa_key_persistence_t for more information."]
#[doc = " - Bits 8-31 (#PSA_KEY_LIFETIME_GET_LOCATION(\\c lifetime)):"]
#[doc = "   location indicator. This value indicates which part of the system"]
#[doc = "   has access to the key material and can perform operations using the key."]
#[doc = "   See ::psa_key_location_t for more information."]
#[doc = ""]
#[doc = " Volatile keys are automatically destroyed when the application instance"]
#[doc = " terminates or on a power reset of the device. Persistent keys are"]
#[doc = " preserved until the application explicitly destroys them or until an"]
#[doc = " integration-specific device management event occurs (for example,"]
#[doc = " a factory reset)."]
#[doc = ""]
#[doc = " Persistent keys have a key identifier of type #psa_key_id_t."]
#[doc = " This identifier remains valid throughout the lifetime of the key,"]
#[doc = " even if the application instance that created the key terminates."]
#[doc = " The application can call psa_open_key() to open a persistent key that"]
#[doc = " it created previously."]
#[doc = ""]
#[doc = " The default lifetime of a key is #PSA_KEY_LIFETIME_VOLATILE. The lifetime"]
#[doc = " #PSA_KEY_LIFETIME_PERSISTENT is supported if persistent storage is"]
#[doc = " available. Other lifetime values may be supported depending on the"]
#[doc = " library configuration."]
pub type psa_key_lifetime_t = u32;
#[doc = " Encoding of key persistence levels."]
#[doc = ""]
#[doc = " What distinguishes different persistence levels is what device management"]
#[doc = " events may cause keys to be destroyed. _Volatile_ keys are destroyed"]
#[doc = " by a power reset. Persistent keys may be destroyed by events such as"]
#[doc = " a transfer of ownership or a factory reset. What management events"]
#[doc = " actually affect persistent keys at different levels is outside the"]
#[doc = " scope of the PSA Cryptography specification."]
#[doc = ""]
#[doc = " The PSA Cryptography specification defines the following values of"]
#[doc = " persistence levels:"]
#[doc = " - \\c 0 = #PSA_KEY_PERSISTENCE_VOLATILE: volatile key."]
#[doc = "   A volatile key is automatically destroyed by the implementation when"]
#[doc = "   the application instance terminates. In particular, a volatile key"]
#[doc = "   is automatically destroyed on a power reset of the device."]
#[doc = " - \\c 1 = #PSA_KEY_PERSISTENCE_DEFAULT:"]
#[doc = "   persistent key with a default lifetime."]
#[doc = " - \\c 2-254: currently not supported by Mbed TLS."]
#[doc = " - \\c 255 = #PSA_KEY_PERSISTENCE_READ_ONLY:"]
#[doc = "   read-only or write-once key."]
#[doc = "   A key with this persistence level cannot be destroyed."]
#[doc = "   Mbed TLS does not currently offer a way to create such keys, but"]
#[doc = "   integrations of Mbed TLS can use it for built-in keys that the"]
#[doc = "   application cannot modify (for example, a hardware unique key (HUK))."]
#[doc = ""]
#[doc = " \\note Key persistence levels are 8-bit values. Key management"]
#[doc = "       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which"]
#[doc = "       encode the persistence as the lower 8 bits of a 32-bit value."]
pub type psa_key_persistence_t = u8;
#[doc = " Encoding of key location indicators."]
#[doc = ""]
#[doc = " If an integration of Mbed TLS can make calls to external"]
#[doc = " cryptoprocessors such as secure elements, the location of a key"]
#[doc = " indicates which secure element performs the operations on the key."]
#[doc = " Depending on the design of the secure element, the key"]
#[doc = " material may be stored either in the secure element, or"]
#[doc = " in wrapped (encrypted) form alongside the key metadata in the"]
#[doc = " primary local storage."]
#[doc = ""]
#[doc = " The PSA Cryptography API specification defines the following values of"]
#[doc = " location indicators:"]
#[doc = " - \\c 0: primary local storage."]
#[doc = "   This location is always available."]
#[doc = "   The primary local storage is typically the same storage area that"]
#[doc = "   contains the key metadata."]
#[doc = " - \\c 1: primary secure element."]
#[doc = "   Integrations of Mbed TLS should support this value if there is a secure"]
#[doc = "   element attached to the operating environment."]
#[doc = "   As a guideline, secure elements may provide higher resistance against"]
#[doc = "   side channel and physical attacks than the primary local storage, but may"]
#[doc = "   have restrictions on supported key types, sizes, policies and operations"]
#[doc = "   and may have different performance characteristics."]
#[doc = " - \\c 2-0x7fffff: other locations defined by a PSA specification."]
#[doc = "   The PSA Cryptography API does not currently assign any meaning to these"]
#[doc = "   locations, but future versions of that specification or other PSA"]
#[doc = "   specifications may do so."]
#[doc = " - \\c 0x800000-0xffffff: vendor-defined locations."]
#[doc = "   No PSA specification will assign a meaning to locations in this range."]
#[doc = ""]
#[doc = " \\note Key location indicators are 24-bit values. Key management"]
#[doc = "       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which"]
#[doc = "       encode the location as the upper 24 bits of a 32-bit value."]
pub type psa_key_location_t = u32;
#[doc = " Encoding of identifiers of persistent keys."]
#[doc = ""]
#[doc = " - Applications may freely choose key identifiers in the range"]
#[doc = "   #PSA_KEY_ID_USER_MIN to #PSA_KEY_ID_USER_MAX."]
#[doc = " - The implementation may define additional key identifiers in the range"]
#[doc = "   #PSA_KEY_ID_VENDOR_MIN to #PSA_KEY_ID_VENDOR_MAX."]
#[doc = " - 0 is reserved as an invalid key identifier."]
#[doc = " - Key identifiers outside these ranges are reserved for future use."]
pub type psa_key_id_t = u32;
#[doc = " \\brief Encoding of permitted usage on a key."]
pub type psa_key_usage_t = u32;
#[doc = " The type of a structure containing key attributes."]
#[doc = ""]
#[doc = " This is an opaque structure that can represent the metadata of a key"]
#[doc = " object. Metadata that can be stored in attributes includes:"]
#[doc = " - The location of the key in storage, indicated by its key identifier"]
#[doc = "   and its lifetime."]
#[doc = " - The key's policy, comprising usage flags and a specification of"]
#[doc = "   the permitted algorithm(s)."]
#[doc = " - Information about the key itself: the key type and its size."]
#[doc = " - Additional implementation-defined attributes."]
#[doc = ""]
#[doc = " The actual key material is not considered an attribute of a key."]
#[doc = " Key attributes do not contain information that is generally considered"]
#[doc = " highly confidential."]
#[doc = ""]
#[doc = " An attribute structure works like a simple data structure where each function"]
#[doc = " `psa_set_key_xxx` sets a field and the corresponding function"]
#[doc = " `psa_get_key_xxx` retrieves the value of the corresponding field."]
#[doc = " However, a future version of the library  may report values that are"]
#[doc = " equivalent to the original one, but have a different encoding. Invalid"]
#[doc = " values may be mapped to different, also invalid values."]
#[doc = ""]
#[doc = " An attribute structure may contain references to auxiliary resources,"]
#[doc = " for example pointers to allocated memory or indirect references to"]
#[doc = " pre-calculated values. In order to free such resources, the application"]
#[doc = " must call psa_reset_key_attributes(). As an exception, calling"]
#[doc = " psa_reset_key_attributes() on an attribute structure is optional if"]
#[doc = " the structure has only been modified by the following functions"]
#[doc = " since it was initialized or last reset with psa_reset_key_attributes():"]
#[doc = " - psa_set_key_id()"]
#[doc = " - psa_set_key_lifetime()"]
#[doc = " - psa_set_key_type()"]
#[doc = " - psa_set_key_bits()"]
#[doc = " - psa_set_key_usage_flags()"]
#[doc = " - psa_set_key_algorithm()"]
#[doc = ""]
#[doc = " Before calling any function on a key attribute structure, the application"]
#[doc = " must initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_attributes_t attributes;"]
#[doc = "   memset(&attributes, 0, sizeof(attributes));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_attributes_t attributes = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_KEY_ATTRIBUTES_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_key_attributes_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_attributes_t attributes;"]
#[doc = "   attributes = psa_key_attributes_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = " A freshly initialized attribute structure contains the following"]
#[doc = " values:"]
#[doc = ""]
#[doc = " - lifetime: #PSA_KEY_LIFETIME_VOLATILE."]
#[doc = " - key identifier: 0 (which is not a valid key identifier)."]
#[doc = " - type: \\c 0 (meaning that the type is unspecified)."]
#[doc = " - key size: \\c 0 (meaning that the size is unspecified)."]
#[doc = " - usage flags: \\c 0 (which allows no usage except exporting a public key)."]
#[doc = " - algorithm: \\c 0 (which allows no cryptographic usage, but allows"]
#[doc = "   exporting)."]
#[doc = ""]
#[doc = " A typical sequence to create a key is as follows:"]
#[doc = " -# Create and initialize an attribute structure."]
#[doc = " -# If the key is persistent, call psa_set_key_id()."]
#[doc = "    Also call psa_set_key_lifetime() to place the key in a non-default"]
#[doc = "    location."]
#[doc = " -# Set the key policy with psa_set_key_usage_flags() and"]
#[doc = "    psa_set_key_algorithm()."]
#[doc = " -# Set the key type with psa_set_key_type()."]
#[doc = "    Skip this step if copying an existing key with psa_copy_key()."]
#[doc = " -# When generating a random key with psa_generate_key() or deriving a key"]
#[doc = "    with psa_key_derivation_output_key(), set the desired key size with"]
#[doc = "    psa_set_key_bits()."]
#[doc = " -# Call a key creation function: psa_import_key(), psa_generate_key(),"]
#[doc = "    psa_key_derivation_output_key() or psa_copy_key(). This function reads"]
#[doc = "    the attribute structure, creates a key with these attributes, and"]
#[doc = "    outputs a key identifier to the newly created key."]
#[doc = " -# The attribute structure is now no longer necessary."]
#[doc = "    You may call psa_reset_key_attributes(), although this is optional"]
#[doc = "    with the workflow presented here because the attributes currently"]
#[doc = "    defined in this specification do not require any additional resources"]
#[doc = "    beyond the structure itself."]
#[doc = ""]
#[doc = " A typical sequence to query a key's attributes is as follows:"]
#[doc = " -# Call psa_get_key_attributes()."]
#[doc = " -# Call `psa_get_key_xxx` functions to retrieve the attribute(s) that"]
#[doc = "    you are interested in."]
#[doc = " -# Call psa_reset_key_attributes() to free any resources that may be"]
#[doc = "    used by the attribute structure."]
#[doc = ""]
#[doc = " Once a key has been created, it is impossible to change its attributes."]
pub type psa_key_attributes_t = psa_client_key_attributes_s;
#[doc = " \\brief Encoding of the step of a key derivation."]
pub type psa_key_derivation_step_t = u16;
extern "C" {
    #[doc = " \\brief Library initialization."]
    #[doc = ""]
    #[doc = " Applications must call this function before calling any other"]
    #[doc = " function in this module."]
    #[doc = ""]
    #[doc = " Applications may call this function more than once. Once a call"]
    #[doc = " succeeds, subsequent calls are guaranteed to succeed."]
    #[doc = ""]
    #[doc = " If the application calls other functions before calling psa_crypto_init(),"]
    #[doc = " the behavior is undefined. Implementations are encouraged to either perform"]
    #[doc = " the operation as if the library had been initialized or to return"]
    #[doc = " #PSA_ERROR_BAD_STATE or some other applicable error. In particular,"]
    #[doc = " implementations should not return a success status if the lack of"]
    #[doc = " initialization may have security implications, for example due to improper"]
    #[doc = " seeding of the random number generator."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_STORAGE"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT"]
    pub fn psa_crypto_init() -> psa_status_t;
}
extern "C" {
    #[doc = " Retrieve the attributes of a key."]
    #[doc = ""]
    #[doc = " This function first resets the attribute structure as with"]
    #[doc = " psa_reset_key_attributes(). It then copies the attributes of"]
    #[doc = " the given key into the given attribute structure."]
    #[doc = ""]
    #[doc = " \\note This function may allocate memory or other resources."]
    #[doc = "       Once you have called this function on an attribute structure,"]
    #[doc = "       you must call psa_reset_key_attributes() to free these resources."]
    #[doc = ""]
    #[doc = " \\param[in] key               Identifier of the key to query."]
    #[doc = " \\param[in,out] attributes    On success, the attributes of the key."]
    #[doc = "                              On failure, equivalent to a"]
    #[doc = "                              freshly-initialized structure."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_get_key_attributes(
        key: psa_key_id_t,
        attributes: *mut psa_key_attributes_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Reset a key attribute structure to a freshly initialized state."]
    #[doc = ""]
    #[doc = " You must initialize the attribute structure as described in the"]
    #[doc = " documentation of the type #psa_key_attributes_t before calling this"]
    #[doc = " function. Once the structure has been initialized, you may call this"]
    #[doc = " function at any time."]
    #[doc = ""]
    #[doc = " This function frees any auxiliary resources that the structure"]
    #[doc = " may contain."]
    #[doc = ""]
    #[doc = " \\param[in,out] attributes    The attribute structure to reset."]
    pub fn psa_reset_key_attributes(attributes: *mut psa_key_attributes_t);
}
extern "C" {
    #[doc = " Remove non-essential copies of key material from memory."]
    #[doc = ""]
    #[doc = " If the key identifier designates a volatile key, this functions does not do"]
    #[doc = " anything and returns successfully."]
    #[doc = ""]
    #[doc = " If the key identifier designates a persistent key, then this function will"]
    #[doc = " free all resources associated with the key in volatile memory. The key"]
    #[doc = " data in persistent storage is not affected and the key can still be used."]
    #[doc = ""]
    #[doc = " \\param key Identifier of the key to purge."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The key material will have been removed from memory if it is not"]
    #[doc = "         currently required."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not a valid key identifier."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_purge_key(key: psa_key_id_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Make a copy of a key."]
    #[doc = ""]
    #[doc = " Copy key material from one location to another."]
    #[doc = ""]
    #[doc = " This function is primarily useful to copy a key from one location"]
    #[doc = " to another, since it populates a key using the material from"]
    #[doc = " another key which may have a different lifetime."]
    #[doc = ""]
    #[doc = " This function may be used to share a key with a different party,"]
    #[doc = " subject to implementation-defined restrictions on key sharing."]
    #[doc = ""]
    #[doc = " The policy on the source key must have the usage flag"]
    #[doc = " #PSA_KEY_USAGE_COPY set."]
    #[doc = " This flag is sufficient to permit the copy if the key has the lifetime"]
    #[doc = " #PSA_KEY_LIFETIME_VOLATILE or #PSA_KEY_LIFETIME_PERSISTENT."]
    #[doc = " Some secure elements do not provide a way to copy a key without"]
    #[doc = " making it extractable from the secure element. If a key is located"]
    #[doc = " in such a secure element, then the key must have both usage flags"]
    #[doc = " #PSA_KEY_USAGE_COPY and #PSA_KEY_USAGE_EXPORT in order to make"]
    #[doc = " a copy of the key outside the secure element."]
    #[doc = ""]
    #[doc = " The resulting key may only be used in a way that conforms to"]
    #[doc = " both the policy of the original key and the policy specified in"]
    #[doc = " the \\p attributes parameter:"]
    #[doc = " - The usage flags on the resulting key are the bitwise-and of the"]
    #[doc = "   usage flags on the source policy and the usage flags in \\p attributes."]
    #[doc = " - If both allow the same algorithm or wildcard-based"]
    #[doc = "   algorithm policy, the resulting key has the same algorithm policy."]
    #[doc = " - If either of the policies allows an algorithm and the other policy"]
    #[doc = "   allows a wildcard-based algorithm policy that includes this algorithm,"]
    #[doc = "   the resulting key allows the same algorithm."]
    #[doc = " - If the policies do not allow any algorithm in common, this function"]
    #[doc = "   fails with the status #PSA_ERROR_INVALID_ARGUMENT."]
    #[doc = ""]
    #[doc = " The effect of this function on implementation-defined attributes is"]
    #[doc = " implementation-defined."]
    #[doc = ""]
    #[doc = " \\param source_key        The key to copy. It must allow the usage"]
    #[doc = "                          #PSA_KEY_USAGE_COPY. If a private or secret key is"]
    #[doc = "                          being copied outside of a secure element it must"]
    #[doc = "                          also allow #PSA_KEY_USAGE_EXPORT."]
    #[doc = " \\param[in] attributes    The attributes for the new key."]
    #[doc = "                          They are used as follows:"]
    #[doc = "                          - The key type and size may be 0. If either is"]
    #[doc = "                            nonzero, it must match the corresponding"]
    #[doc = "                            attribute of the source key."]
    #[doc = "                          - The key location (the lifetime and, for"]
    #[doc = "                            persistent keys, the key identifier) is"]
    #[doc = "                            used directly."]
    #[doc = "                          - The policy constraints (usage flags and"]
    #[doc = "                            algorithm policy) are combined from"]
    #[doc = "                            the source key and \\p attributes so that"]
    #[doc = "                            both sets of restrictions apply, as"]
    #[doc = "                            described in the documentation of this function."]
    #[doc = " \\param[out] target_key   On success, an identifier for the newly created"]
    #[doc = "                          key. For persistent keys, this is the key"]
    #[doc = "                          identifier defined in \\p attributes."]
    #[doc = "                          \\c 0 on failure."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = "         \\p source_key is invalid."]
    #[doc = " \\retval #PSA_ERROR_ALREADY_EXISTS"]
    #[doc = "         This is an attempt to create a persistent key, and there is"]
    #[doc = "         already a persistent key with the given identifier."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The lifetime or identifier in \\p attributes are invalid."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The policy constraints on the source and specified in"]
    #[doc = "         \\p attributes are incompatible."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p attributes specifies a key type or key size"]
    #[doc = "         which does not match the attributes of the source key."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The source key does not have the #PSA_KEY_USAGE_COPY usage flag."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The source key is not exportable and its lifetime does not"]
    #[doc = "         allow copying it to the target's lifetime."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_STORAGE"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_copy_key(
        source_key: psa_key_id_t,
        attributes: *const psa_key_attributes_t,
        target_key: *mut psa_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Destroy a key."]
    #[doc = ""]
    #[doc = " This function destroys a key from both volatile"]
    #[doc = " memory and, if applicable, non-volatile storage. Implementations shall"]
    #[doc = " make a best effort to ensure that that the key material cannot be recovered."]
    #[doc = ""]
    #[doc = " This function also erases any metadata such as policies and frees"]
    #[doc = " resources associated with the key."]
    #[doc = ""]
    #[doc = " If a key is currently in use in a multipart operation, then destroying the"]
    #[doc = " key will cause the multipart operation to fail."]
    #[doc = ""]
    #[doc = " \\param key  Identifier of the key to erase. If this is \\c 0, do nothing and"]
    #[doc = "             return #PSA_SUCCESS."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         \\p key was a valid identifier and the key material that it"]
    #[doc = "         referred to has been erased. Alternatively, \\p key is \\c 0."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key cannot be erased because it is"]
    #[doc = "         read-only, either due to a policy or due to physical restrictions."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = "         \\p key is not a valid identifier nor \\c 0."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = "         There was an failure in communication with the cryptoprocessor."]
    #[doc = "         The key material may still be present in the cryptoprocessor."]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID"]
    #[doc = "         This error is typically a result of either storage corruption on a"]
    #[doc = "         cleartext storage backend, or an attempt to read data that was"]
    #[doc = "         written by an incompatible version of the library."]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         The storage is corrupted. Implementations shall make a best effort"]
    #[doc = "         to erase key material even in this stage, however applications"]
    #[doc = "         should be aware that it may be impossible to guarantee that the"]
    #[doc = "         key material is not recoverable in such cases."]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = "         An unexpected condition which is not a storage corruption or"]
    #[doc = "         a communication failure occurred. The cryptoprocessor may have"]
    #[doc = "         been compromised."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_destroy_key(key: psa_key_id_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Import a key in binary format."]
    #[doc = ""]
    #[doc = " This function supports any output from psa_export_key(). Refer to the"]
    #[doc = " documentation of psa_export_public_key() for the format of public keys"]
    #[doc = " and to the documentation of psa_export_key() for the format for"]
    #[doc = " other key types."]
    #[doc = ""]
    #[doc = " The key data determines the key size. The attributes may optionally"]
    #[doc = " specify a key size; in this case it must match the size determined"]
    #[doc = " from the key data. A key size of 0 in \\p attributes indicates that"]
    #[doc = " the key size is solely determined by the key data."]
    #[doc = ""]
    #[doc = " Implementations must reject an attempt to import a key of size 0."]
    #[doc = ""]
    #[doc = " This specification supports a single format for each key type."]
    #[doc = " Implementations may support other formats as long as the standard"]
    #[doc = " format is supported. Implementations that support other formats"]
    #[doc = " should ensure that the formats are clearly unambiguous so as to"]
    #[doc = " minimize the risk that an invalid input is accidentally interpreted"]
    #[doc = " according to a different format."]
    #[doc = ""]
    #[doc = " \\param[in] attributes    The attributes for the new key."]
    #[doc = "                          The key size is always determined from the"]
    #[doc = "                          \\p data buffer."]
    #[doc = "                          If the key size in \\p attributes is nonzero,"]
    #[doc = "                          it must be equal to the size from \\p data."]
    #[doc = " \\param[out] key          On success, an identifier to the newly created key."]
    #[doc = "                          For persistent keys, this is the key identifier"]
    #[doc = "                          defined in \\p attributes."]
    #[doc = "                          \\c 0 on failure."]
    #[doc = " \\param[in] data    Buffer containing the key data. The content of this"]
    #[doc = "                    buffer is interpreted according to the type declared"]
    #[doc = "                    in \\p attributes."]
    #[doc = "                    All implementations must support at least the format"]
    #[doc = "                    described in the documentation"]
    #[doc = "                    of psa_export_key() or psa_export_public_key() for"]
    #[doc = "                    the chosen type. Implementations may allow other"]
    #[doc = "                    formats, but should be conservative: implementations"]
    #[doc = "                    should err on the side of rejecting content if it"]
    #[doc = "                    may be erroneous (e.g. wrong type or truncated data)."]
    #[doc = " \\param data_length Size of the \\p data buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = "         If the key is persistent, the key material and the key's metadata"]
    #[doc = "         have been saved to persistent storage."]
    #[doc = " \\retval #PSA_ERROR_ALREADY_EXISTS"]
    #[doc = "         This is an attempt to create a persistent key, and there is"]
    #[doc = "         already a persistent key with the given identifier."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         The key type or key size is not supported, either by the"]
    #[doc = "         implementation in general or in this particular persistent location."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The key attributes, as a whole, are invalid."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The key data is not correctly formatted."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The size in \\p attributes is nonzero and does not match the size"]
    #[doc = "         of the key data."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_STORAGE"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_import_key(
        attributes: *const psa_key_attributes_t,
        data: *const u8,
        data_length: size_t,
        key: *mut psa_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Export a key in binary format."]
    #[doc = ""]
    #[doc = " The output of this function can be passed to psa_import_key() to"]
    #[doc = " create an equivalent object."]
    #[doc = ""]
    #[doc = " If the implementation of psa_import_key() supports other formats"]
    #[doc = " beyond the format specified here, the output from psa_export_key()"]
    #[doc = " must use the representation specified here, not the original"]
    #[doc = " representation."]
    #[doc = ""]
    #[doc = " For standard key types, the output format is as follows:"]
    #[doc = ""]
    #[doc = " - For symmetric keys (including MAC keys), the format is the"]
    #[doc = "   raw bytes of the key."]
    #[doc = " - For DES, the key data consists of 8 bytes. The parity bits must be"]
    #[doc = "   correct."]
    #[doc = " - For Triple-DES, the format is the concatenation of the"]
    #[doc = "   two or three DES keys."]
    #[doc = " - For RSA key pairs (#PSA_KEY_TYPE_RSA_KEY_PAIR), the format"]
    #[doc = "   is the non-encrypted DER encoding of the representation defined by"]
    #[doc = "   PKCS\\#1 (RFC 8017) as `RSAPrivateKey`, version 0."]
    #[doc = "   ```"]
    #[doc = "   RSAPrivateKey ::= SEQUENCE {"]
    #[doc = "       version             INTEGER,  -- must be 0"]
    #[doc = "       modulus             INTEGER,  -- n"]
    #[doc = "       publicExponent      INTEGER,  -- e"]
    #[doc = "       privateExponent     INTEGER,  -- d"]
    #[doc = "       prime1              INTEGER,  -- p"]
    #[doc = "       prime2              INTEGER,  -- q"]
    #[doc = "       exponent1           INTEGER,  -- d mod (p-1)"]
    #[doc = "       exponent2           INTEGER,  -- d mod (q-1)"]
    #[doc = "       coefficient         INTEGER,  -- (inverse of q) mod p"]
    #[doc = "   }"]
    #[doc = "   ```"]
    #[doc = " - For elliptic curve key pairs (key types for which"]
    #[doc = "   #PSA_KEY_TYPE_IS_ECC_KEY_PAIR is true), the format is"]
    #[doc = "   a representation of the private value as a `ceiling(m/8)`-byte string"]
    #[doc = "   where `m` is the bit size associated with the curve, i.e. the bit size"]
    #[doc = "   of the order of the curve's coordinate field. This byte string is"]
    #[doc = "   in little-endian order for Montgomery curves (curve types"]
    #[doc = "   `PSA_ECC_FAMILY_CURVEXXX`), and in big-endian order for Weierstrass"]
    #[doc = "   curves (curve types `PSA_ECC_FAMILY_SECTXXX`, `PSA_ECC_FAMILY_SECPXXX`"]
    #[doc = "   and `PSA_ECC_FAMILY_BRAINPOOL_PXXX`)."]
    #[doc = "   For Weierstrass curves, this is the content of the `privateKey` field of"]
    #[doc = "   the `ECPrivateKey` format defined by RFC 5915.  For Montgomery curves,"]
    #[doc = "   the format is defined by RFC 7748, and output is masked according to §5."]
    #[doc = "   For twisted Edwards curves, the private key is as defined by RFC 8032"]
    #[doc = "   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448)."]
    #[doc = " - For Diffie-Hellman key exchange key pairs (key types for which"]
    #[doc = "   #PSA_KEY_TYPE_IS_DH_KEY_PAIR is true), the"]
    #[doc = "   format is the representation of the private key `x` as a big-endian byte"]
    #[doc = "   string. The length of the byte string is the private key size in bytes"]
    #[doc = "   (leading zeroes are not stripped)."]
    #[doc = " - For public keys (key types for which #PSA_KEY_TYPE_IS_PUBLIC_KEY is"]
    #[doc = "   true), the format is the same as for psa_export_public_key()."]
    #[doc = ""]
    #[doc = " The policy on the key must have the usage flag #PSA_KEY_USAGE_EXPORT set."]
    #[doc = ""]
    #[doc = " \\param key               Identifier of the key to export. It must allow the"]
    #[doc = "                          usage #PSA_KEY_USAGE_EXPORT, unless it is a public"]
    #[doc = "                          key."]
    #[doc = " \\param[out] data         Buffer where the key data is to be written."]
    #[doc = " \\param data_size         Size of the \\p data buffer in bytes."]
    #[doc = " \\param[out] data_length  On success, the number of bytes"]
    #[doc = "                          that make up the key data."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key does not have the #PSA_KEY_USAGE_EXPORT flag."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p data buffer is too small. You can determine a"]
    #[doc = "         sufficient buffer size by calling"]
    #[doc = "         #PSA_EXPORT_KEY_OUTPUT_SIZE(\\c type, \\c bits)"]
    #[doc = "         where \\c type is the key type"]
    #[doc = "         and \\c bits is the key size in bits."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_export_key(
        key: psa_key_id_t,
        data: *mut u8,
        data_size: size_t,
        data_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Export a public key or the public part of a key pair in binary format."]
    #[doc = ""]
    #[doc = " The output of this function can be passed to psa_import_key() to"]
    #[doc = " create an object that is equivalent to the public key."]
    #[doc = ""]
    #[doc = " This specification supports a single format for each key type."]
    #[doc = " Implementations may support other formats as long as the standard"]
    #[doc = " format is supported. Implementations that support other formats"]
    #[doc = " should ensure that the formats are clearly unambiguous so as to"]
    #[doc = " minimize the risk that an invalid input is accidentally interpreted"]
    #[doc = " according to a different format."]
    #[doc = ""]
    #[doc = " For standard key types, the output format is as follows:"]
    #[doc = " - For RSA public keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY), the DER encoding of"]
    #[doc = "   the representation defined by RFC 3279 &sect;2.3.1 as `RSAPublicKey`."]
    #[doc = "   ```"]
    #[doc = "   RSAPublicKey ::= SEQUENCE {"]
    #[doc = "      modulus            INTEGER,    -- n"]
    #[doc = "      publicExponent     INTEGER  }  -- e"]
    #[doc = "   ```"]
    #[doc = " - For elliptic curve keys on a twisted Edwards curve (key types for which"]
    #[doc = "   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true and #PSA_KEY_TYPE_ECC_GET_FAMILY"]
    #[doc = "   returns #PSA_ECC_FAMILY_TWISTED_EDWARDS), the public key is as defined"]
    #[doc = "   by RFC 8032"]
    #[doc = "   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448)."]
    #[doc = " - For other elliptic curve public keys (key types for which"]
    #[doc = "   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true), the format is the uncompressed"]
    #[doc = "   representation defined by SEC1 &sect;2.3.3 as the content of an ECPoint."]
    #[doc = "   Let `m` be the bit size associated with the curve, i.e. the bit size of"]
    #[doc = "   `q` for a curve over `F_q`. The representation consists of:"]
    #[doc = "      - The byte 0x04;"]
    #[doc = "      - `x_P` as a `ceiling(m/8)`-byte string, big-endian;"]
    #[doc = "      - `y_P` as a `ceiling(m/8)`-byte string, big-endian."]
    #[doc = " - For Diffie-Hellman key exchange public keys (key types for which"]
    #[doc = "   #PSA_KEY_TYPE_IS_DH_PUBLIC_KEY is true),"]
    #[doc = "   the format is the representation of the public key `y = g^x mod p` as a"]
    #[doc = "   big-endian byte string. The length of the byte string is the length of the"]
    #[doc = "   base prime `p` in bytes."]
    #[doc = ""]
    #[doc = " Exporting a public key object or the public part of a key pair is"]
    #[doc = " always permitted, regardless of the key's usage flags."]
    #[doc = ""]
    #[doc = " \\param key               Identifier of the key to export."]
    #[doc = " \\param[out] data         Buffer where the key data is to be written."]
    #[doc = " \\param data_size         Size of the \\p data buffer in bytes."]
    #[doc = " \\param[out] data_length  On success, the number of bytes"]
    #[doc = "                          that make up the key data."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The key is neither a public key nor a key pair."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p data buffer is too small. You can determine a"]
    #[doc = "         sufficient buffer size by calling"]
    #[doc = "         #PSA_EXPORT_KEY_OUTPUT_SIZE(#PSA_KEY_TYPE_PUBLIC_KEY_OF_KEY_PAIR(\\c type), \\c bits)"]
    #[doc = "         where \\c type is the key type"]
    #[doc = "         and \\c bits is the key size in bits."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_export_public_key(
        key: psa_key_id_t,
        data: *mut u8,
        data_size: size_t,
        data_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the hash (digest) of a message."]
    #[doc = ""]
    #[doc = " \\note To verify the hash of a message against an"]
    #[doc = "       expected value, use psa_hash_compare() instead."]
    #[doc = ""]
    #[doc = " \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_HASH(\\p alg) is true)."]
    #[doc = " \\param[in] input         Buffer containing the message to hash."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] hash         Buffer where the hash is to be written."]
    #[doc = " \\param hash_size         Size of the \\p hash buffer in bytes."]
    #[doc = " \\param[out] hash_length  On success, the number of bytes"]
    #[doc = "                          that make up the hash value. This is always"]
    #[doc = "                          #PSA_HASH_LENGTH(\\p alg)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a hash algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         \\p hash_size is too small"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_compute(
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        hash: *mut u8,
        hash_size: size_t,
        hash_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the hash (digest) of a message and compare it with a"]
    #[doc = " reference value."]
    #[doc = ""]
    #[doc = " \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_HASH(\\p alg) is true)."]
    #[doc = " \\param[in] input         Buffer containing the message to hash."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] hash         Buffer containing the expected hash value."]
    #[doc = " \\param hash_length       Size of the \\p hash buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The expected hash is identical to the actual hash of the input."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The hash of the message was calculated successfully, but it"]
    #[doc = "         differs from the expected hash."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a hash algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p input_length or \\p hash_length do not match the hash size for \\p alg"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_compare(
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        hash: *const u8,
        hash_length: size_t,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart hash operations."]
#[doc = ""]
#[doc = " Before calling any function on a hash operation object, the application must"]
#[doc = " initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_hash_operation_t operation;"]
#[doc = "   memset(&operation, 0, sizeof(operation));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_hash_operation_t operation = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_HASH_OPERATION_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_hash_operation_t operation = PSA_HASH_OPERATION_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_hash_operation_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_hash_operation_t operation;"]
#[doc = "   operation = psa_hash_operation_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_hash_operation_t = psa_hash_operation_s;
extern "C" {
    #[doc = " Set up a multipart hash operation."]
    #[doc = ""]
    #[doc = " The sequence of operations to calculate a hash (message digest)"]
    #[doc = " is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_hash_operation_t, e.g. #PSA_HASH_OPERATION_INIT."]
    #[doc = " -# Call psa_hash_setup() to specify the algorithm."]
    #[doc = " -# Call psa_hash_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message each time. The hash that is calculated is the hash"]
    #[doc = "    of the concatenation of these messages in order."]
    #[doc = " -# To calculate the hash, call psa_hash_finish()."]
    #[doc = "    To compare the hash with an expected value, call psa_hash_verify()."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_hash_setup(), the"]
    #[doc = " operation will need to be reset by a call to psa_hash_abort(). The"]
    #[doc = " application may call psa_hash_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_hash_setup(), the application must"]
    #[doc = " eventually terminate the operation. The following events terminate an"]
    #[doc = " operation:"]
    #[doc = " - A successful call to psa_hash_finish() or psa_hash_verify()."]
    #[doc = " - A call to psa_hash_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The operation object to set up. It must have"]
    #[doc = "                          been initialized as per the documentation for"]
    #[doc = "                          #psa_hash_operation_t and not yet in use."]
    #[doc = " \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_HASH(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not a supported hash algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p alg is not a hash algorithm."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive)."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_setup(
        operation: *mut psa_hash_operation_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Add a message fragment to a multipart hash operation."]
    #[doc = ""]
    #[doc = " The application must call psa_hash_setup() before calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_hash_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation Active hash operation."]
    #[doc = " \\param[in] input         Buffer containing the message fragment to hash."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it muct be active)."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_update(
        operation: *mut psa_hash_operation_t,
        input: *const u8,
        input_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the hash of a message."]
    #[doc = ""]
    #[doc = " The application must call psa_hash_setup() before calling this function."]
    #[doc = " This function calculates the hash of the message formed by concatenating"]
    #[doc = " the inputs passed to preceding calls to psa_hash_update()."]
    #[doc = ""]
    #[doc = " When this function returns successfuly, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_hash_abort()."]
    #[doc = ""]
    #[doc = " \\warning Applications should not call this function if they expect"]
    #[doc = "          a specific value for the hash. Call psa_hash_verify() instead."]
    #[doc = "          Beware that comparing integrity or authenticity data such as"]
    #[doc = "          hash values with a function such as \\c memcmp is risky"]
    #[doc = "          because the time taken by the comparison may leak information"]
    #[doc = "          about the hashed data which could allow an attacker to guess"]
    #[doc = "          a valid hash and thereby bypass security controls."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active hash operation."]
    #[doc = " \\param[out] hash             Buffer where the hash is to be written."]
    #[doc = " \\param hash_size             Size of the \\p hash buffer in bytes."]
    #[doc = " \\param[out] hash_length      On success, the number of bytes"]
    #[doc = "                              that make up the hash value. This is always"]
    #[doc = "                              #PSA_HASH_LENGTH(\\c alg) where \\c alg is the"]
    #[doc = "                              hash algorithm that is calculated."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active)."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p hash buffer is too small. You can determine a"]
    #[doc = "         sufficient buffer size by calling #PSA_HASH_LENGTH(\\c alg)"]
    #[doc = "         where \\c alg is the hash algorithm that is calculated."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_finish(
        operation: *mut psa_hash_operation_t,
        hash: *mut u8,
        hash_size: size_t,
        hash_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the hash of a message and compare it with"]
    #[doc = " an expected value."]
    #[doc = ""]
    #[doc = " The application must call psa_hash_setup() before calling this function."]
    #[doc = " This function calculates the hash of the message formed by concatenating"]
    #[doc = " the inputs passed to preceding calls to psa_hash_update(). It then"]
    #[doc = " compares the calculated hash with the expected hash passed as a"]
    #[doc = " parameter to this function."]
    #[doc = ""]
    #[doc = " When this function returns successfuly, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_hash_abort()."]
    #[doc = ""]
    #[doc = " \\note Implementations shall make the best effort to ensure that the"]
    #[doc = " comparison between the actual hash and the expected hash is performed"]
    #[doc = " in constant time."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active hash operation."]
    #[doc = " \\param[in] hash              Buffer containing the expected hash value."]
    #[doc = " \\param hash_length           Size of the \\p hash buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The expected hash is identical to the actual hash of the message."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The hash of the message was calculated successfully, but it"]
    #[doc = "         differs from the expected hash."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active)."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_verify(
        operation: *mut psa_hash_operation_t,
        hash: *const u8,
        hash_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a hash operation."]
    #[doc = ""]
    #[doc = " Aborting an operation frees all associated resources except for the"]
    #[doc = " \\p operation structure itself. Once aborted, the operation object"]
    #[doc = " can be reused for another operation by calling"]
    #[doc = " psa_hash_setup() again."]
    #[doc = ""]
    #[doc = " You may call this function any time after the operation object has"]
    #[doc = " been initialized by one of the methods described in #psa_hash_operation_t."]
    #[doc = ""]
    #[doc = " In particular, calling psa_hash_abort() after the operation has been"]
    #[doc = " terminated by a call to psa_hash_abort(), psa_hash_finish() or"]
    #[doc = " psa_hash_verify() is safe and has no effect."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Initialized hash operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_abort(operation: *mut psa_hash_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Clone a hash operation."]
    #[doc = ""]
    #[doc = " This function copies the state of an ongoing hash operation to"]
    #[doc = " a new operation object. In other words, this function is equivalent"]
    #[doc = " to calling psa_hash_setup() on \\p target_operation with the same"]
    #[doc = " algorithm that \\p source_operation was set up for, then"]
    #[doc = " psa_hash_update() on \\p target_operation with the same input that"]
    #[doc = " that was passed to \\p source_operation. After this function returns, the"]
    #[doc = " two objects are independent, i.e. subsequent calls involving one of"]
    #[doc = " the objects do not affect the other object."]
    #[doc = ""]
    #[doc = " \\param[in] source_operation      The active hash operation to clone."]
    #[doc = " \\param[in,out] target_operation  The operation object to set up."]
    #[doc = "                                  It must be initialized but not active."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The \\p source_operation state is not valid (it must be active)."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The \\p target_operation state is not valid (it must be inactive)."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_hash_clone(
        source_operation: *const psa_hash_operation_t,
        target_operation: *mut psa_hash_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the MAC (message authentication code) of a message."]
    #[doc = ""]
    #[doc = " \\note To verify the MAC of a message against an"]
    #[doc = "       expected value, use psa_mac_verify() instead."]
    #[doc = "       Beware that comparing integrity or authenticity data such as"]
    #[doc = "       MAC values with a function such as \\c memcmp is risky"]
    #[doc = "       because the time taken by the comparison may leak information"]
    #[doc = "       about the MAC value which could allow an attacker to guess"]
    #[doc = "       a valid MAC and thereby bypass security controls."]
    #[doc = ""]
    #[doc = " \\param key               Identifier of the key to use for the operation. It"]
    #[doc = "                          must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE."]
    #[doc = " \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_MAC(\\p alg) is true)."]
    #[doc = " \\param[in] input         Buffer containing the input message."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] mac          Buffer where the MAC value is to be written."]
    #[doc = " \\param mac_size          Size of the \\p mac buffer in bytes."]
    #[doc = " \\param[out] mac_length   On success, the number of bytes"]
    #[doc = "                          that make up the MAC value."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a MAC algorithm."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         \\p mac_size is too small"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         The key could not be retrieved from storage."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_compute(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        mac: *mut u8,
        mac_size: size_t,
        mac_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the MAC of a message and compare it with a reference value."]
    #[doc = ""]
    #[doc = " \\param key               Identifier of the key to use for the operation. It"]
    #[doc = "                          must allow the usage PSA_KEY_USAGE_VERIFY_MESSAGE."]
    #[doc = " \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_MAC(\\p alg) is true)."]
    #[doc = " \\param[in] input         Buffer containing the input message."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] mac          Buffer containing the expected MAC value."]
    #[doc = " \\param mac_length        Size of the \\p mac buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The expected MAC is identical to the actual MAC of the input."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The MAC of the message was calculated successfully, but it"]
    #[doc = "         differs from the expected value."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a MAC algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         The key could not be retrieved from storage."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_verify(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        mac: *const u8,
        mac_length: size_t,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart MAC operations."]
#[doc = ""]
#[doc = " Before calling any function on a MAC operation object, the application must"]
#[doc = " initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_mac_operation_t operation;"]
#[doc = "   memset(&operation, 0, sizeof(operation));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_mac_operation_t operation = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_MAC_OPERATION_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_mac_operation_t operation = PSA_MAC_OPERATION_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_mac_operation_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_mac_operation_t operation;"]
#[doc = "   operation = psa_mac_operation_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_mac_operation_t = psa_mac_operation_s;
extern "C" {
    #[doc = " Set up a multipart MAC calculation operation."]
    #[doc = ""]
    #[doc = " This function sets up the calculation of the MAC"]
    #[doc = " (message authentication code) of a byte string."]
    #[doc = " To verify the MAC of a message against an"]
    #[doc = " expected value, use psa_mac_verify_setup() instead."]
    #[doc = ""]
    #[doc = " The sequence of operations to calculate a MAC is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT."]
    #[doc = " -# Call psa_mac_sign_setup() to specify the algorithm and key."]
    #[doc = " -# Call psa_mac_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message each time. The MAC that is calculated is the MAC"]
    #[doc = "    of the concatenation of these messages in order."]
    #[doc = " -# At the end of the message, call psa_mac_sign_finish() to finish"]
    #[doc = "    calculating the MAC value and retrieve it."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_mac_sign_setup(), the"]
    #[doc = " operation will need to be reset by a call to psa_mac_abort(). The"]
    #[doc = " application may call psa_mac_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_mac_sign_setup(), the application must"]
    #[doc = " eventually terminate the operation through one of the following methods:"]
    #[doc = " - A successful call to psa_mac_sign_finish()."]
    #[doc = " - A call to psa_mac_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The operation object to set up. It must have"]
    #[doc = "                          been initialized as per the documentation for"]
    #[doc = "                          #psa_mac_operation_t and not yet in use."]
    #[doc = " \\param key               Identifier of the key to use for the operation. It"]
    #[doc = "                          must remain valid until the operation terminates."]
    #[doc = "                          It must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE."]
    #[doc = " \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_MAC(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a MAC algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         The key could not be retrieved from storage."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive)."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_sign_setup(
        operation: *mut psa_mac_operation_t,
        key: psa_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set up a multipart MAC verification operation."]
    #[doc = ""]
    #[doc = " This function sets up the verification of the MAC"]
    #[doc = " (message authentication code) of a byte string against an expected value."]
    #[doc = ""]
    #[doc = " The sequence of operations to verify a MAC is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT."]
    #[doc = " -# Call psa_mac_verify_setup() to specify the algorithm and key."]
    #[doc = " -# Call psa_mac_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message each time. The MAC that is calculated is the MAC"]
    #[doc = "    of the concatenation of these messages in order."]
    #[doc = " -# At the end of the message, call psa_mac_verify_finish() to finish"]
    #[doc = "    calculating the actual MAC of the message and verify it against"]
    #[doc = "    the expected value."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_mac_verify_setup(), the"]
    #[doc = " operation will need to be reset by a call to psa_mac_abort(). The"]
    #[doc = " application may call psa_mac_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_mac_verify_setup(), the application must"]
    #[doc = " eventually terminate the operation through one of the following methods:"]
    #[doc = " - A successful call to psa_mac_verify_finish()."]
    #[doc = " - A call to psa_mac_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The operation object to set up. It must have"]
    #[doc = "                          been initialized as per the documentation for"]
    #[doc = "                          #psa_mac_operation_t and not yet in use."]
    #[doc = " \\param key               Identifier of the key to use for the operation. It"]
    #[doc = "                          must remain valid until the operation terminates."]
    #[doc = "                          It must allow the usage"]
    #[doc = "                          PSA_KEY_USAGE_VERIFY_MESSAGE."]
    #[doc = " \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value"]
    #[doc = "                          such that #PSA_ALG_IS_MAC(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c key is not compatible with \\c alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\c alg is not supported or is not a MAC algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = "         The key could not be retrieved from storage"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive)."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_verify_setup(
        operation: *mut psa_mac_operation_t,
        key: psa_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Add a message fragment to a multipart MAC operation."]
    #[doc = ""]
    #[doc = " The application must call psa_mac_sign_setup() or psa_mac_verify_setup()"]
    #[doc = " before calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_mac_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation Active MAC operation."]
    #[doc = " \\param[in] input         Buffer containing the message fragment to add to"]
    #[doc = "                          the MAC calculation."]
    #[doc = " \\param input_length      Size of the \\p input buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active)."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_update(
        operation: *mut psa_mac_operation_t,
        input: *const u8,
        input_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the MAC of a message."]
    #[doc = ""]
    #[doc = " The application must call psa_mac_sign_setup() before calling this function."]
    #[doc = " This function calculates the MAC of the message formed by concatenating"]
    #[doc = " the inputs passed to preceding calls to psa_mac_update()."]
    #[doc = ""]
    #[doc = " When this function returns successfuly, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_mac_abort()."]
    #[doc = ""]
    #[doc = " \\warning Applications should not call this function if they expect"]
    #[doc = "          a specific value for the MAC. Call psa_mac_verify_finish() instead."]
    #[doc = "          Beware that comparing integrity or authenticity data such as"]
    #[doc = "          MAC values with a function such as \\c memcmp is risky"]
    #[doc = "          because the time taken by the comparison may leak information"]
    #[doc = "          about the MAC value which could allow an attacker to guess"]
    #[doc = "          a valid MAC and thereby bypass security controls."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation Active MAC operation."]
    #[doc = " \\param[out] mac          Buffer where the MAC value is to be written."]
    #[doc = " \\param mac_size          Size of the \\p mac buffer in bytes."]
    #[doc = " \\param[out] mac_length   On success, the number of bytes"]
    #[doc = "                          that make up the MAC value. This is always"]
    #[doc = "                          #PSA_MAC_LENGTH(\\c key_type, \\c key_bits, \\c alg)"]
    #[doc = "                          where \\c key_type and \\c key_bits are the type and"]
    #[doc = "                          bit-size respectively of the key and \\c alg is the"]
    #[doc = "                          MAC algorithm that is calculated."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active mac sign"]
    #[doc = "         operation)."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p mac buffer is too small. You can determine a"]
    #[doc = "         sufficient buffer size by calling PSA_MAC_LENGTH()."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_sign_finish(
        operation: *mut psa_mac_operation_t,
        mac: *mut u8,
        mac_size: size_t,
        mac_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the MAC of a message and compare it with"]
    #[doc = " an expected value."]
    #[doc = ""]
    #[doc = " The application must call psa_mac_verify_setup() before calling this function."]
    #[doc = " This function calculates the MAC of the message formed by concatenating"]
    #[doc = " the inputs passed to preceding calls to psa_mac_update(). It then"]
    #[doc = " compares the calculated MAC with the expected MAC passed as a"]
    #[doc = " parameter to this function."]
    #[doc = ""]
    #[doc = " When this function returns successfuly, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_mac_abort()."]
    #[doc = ""]
    #[doc = " \\note Implementations shall make the best effort to ensure that the"]
    #[doc = " comparison between the actual MAC and the expected MAC is performed"]
    #[doc = " in constant time."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation Active MAC operation."]
    #[doc = " \\param[in] mac           Buffer containing the expected MAC value."]
    #[doc = " \\param mac_length        Size of the \\p mac buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The expected MAC is identical to the actual MAC of the message."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The MAC of the message was calculated successfully, but it"]
    #[doc = "         differs from the expected MAC."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active mac verify"]
    #[doc = "         operation)."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_verify_finish(
        operation: *mut psa_mac_operation_t,
        mac: *const u8,
        mac_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a MAC operation."]
    #[doc = ""]
    #[doc = " Aborting an operation frees all associated resources except for the"]
    #[doc = " \\p operation structure itself. Once aborted, the operation object"]
    #[doc = " can be reused for another operation by calling"]
    #[doc = " psa_mac_sign_setup() or psa_mac_verify_setup() again."]
    #[doc = ""]
    #[doc = " You may call this function any time after the operation object has"]
    #[doc = " been initialized by one of the methods described in #psa_mac_operation_t."]
    #[doc = ""]
    #[doc = " In particular, calling psa_mac_abort() after the operation has been"]
    #[doc = " terminated by a call to psa_mac_abort(), psa_mac_sign_finish() or"]
    #[doc = " psa_mac_verify_finish() is safe and has no effect."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation Initialized MAC operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_mac_abort(operation: *mut psa_mac_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt a message using a symmetric cipher."]
    #[doc = ""]
    #[doc = " This function encrypts a message with a random IV (initialization"]
    #[doc = " vector). Use the multipart operation interface with a"]
    #[doc = " #psa_cipher_operation_t object to provide other forms of IV."]
    #[doc = ""]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must allow the usage #PSA_KEY_USAGE_ENCRYPT."]
    #[doc = " \\param alg                   The cipher algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_CIPHER(\\p alg) is true)."]
    #[doc = " \\param[in] input             Buffer containing the message to encrypt."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] output           Buffer where the output is to be written."]
    #[doc = "                              The output contains the IV followed by"]
    #[doc = "                              the ciphertext proper."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a cipher algorithm."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_encrypt(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Decrypt a message using a symmetric cipher."]
    #[doc = ""]
    #[doc = " This function decrypts a message encrypted with a symmetric cipher."]
    #[doc = ""]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must remain valid until the operation"]
    #[doc = "                              terminates. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_DECRYPT."]
    #[doc = " \\param alg                   The cipher algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_CIPHER(\\p alg) is true)."]
    #[doc = " \\param[in] input             Buffer containing the message to decrypt."]
    #[doc = "                              This consists of the IV followed by the"]
    #[doc = "                              ciphertext proper."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] output           Buffer where the plaintext is to be written."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a cipher algorithm."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_decrypt(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart cipher operations."]
#[doc = ""]
#[doc = " Before calling any function on a cipher operation object, the application"]
#[doc = " must initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_cipher_operation_t operation;"]
#[doc = "   memset(&operation, 0, sizeof(operation));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_cipher_operation_t operation = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_CIPHER_OPERATION_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_cipher_operation_t operation = PSA_CIPHER_OPERATION_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_cipher_operation_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_cipher_operation_t operation;"]
#[doc = "   operation = psa_cipher_operation_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_cipher_operation_t = psa_cipher_operation_s;
extern "C" {
    #[doc = " Set the key for a multipart symmetric encryption operation."]
    #[doc = ""]
    #[doc = " The sequence of operations to encrypt a message with a symmetric cipher"]
    #[doc = " is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_cipher_operation_t, e.g."]
    #[doc = "    #PSA_CIPHER_OPERATION_INIT."]
    #[doc = " -# Call psa_cipher_encrypt_setup() to specify the algorithm and key."]
    #[doc = " -# Call either psa_cipher_generate_iv() or psa_cipher_set_iv() to"]
    #[doc = "    generate or set the IV (initialization vector). You should use"]
    #[doc = "    psa_cipher_generate_iv() unless the protocol you are implementing"]
    #[doc = "    requires a specific IV value."]
    #[doc = " -# Call psa_cipher_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message each time."]
    #[doc = " -# Call psa_cipher_finish()."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_cipher_encrypt_setup(),"]
    #[doc = " the operation will need to be reset by a call to psa_cipher_abort(). The"]
    #[doc = " application may call psa_cipher_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_cipher_encrypt_setup(), the application must"]
    #[doc = " eventually terminate the operation. The following events terminate an"]
    #[doc = " operation:"]
    #[doc = " - A successful call to psa_cipher_finish()."]
    #[doc = " - A call to psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set up. It must have"]
    #[doc = "                              been initialized as per the documentation for"]
    #[doc = "                              #psa_cipher_operation_t and not yet in use."]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must remain valid until the operation"]
    #[doc = "                              terminates. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_ENCRYPT."]
    #[doc = " \\param alg                   The cipher algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_CIPHER(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a cipher algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive)."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_encrypt_setup(
        operation: *mut psa_cipher_operation_t,
        key: psa_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the key for a multipart symmetric decryption operation."]
    #[doc = ""]
    #[doc = " The sequence of operations to decrypt a message with a symmetric cipher"]
    #[doc = " is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_cipher_operation_t, e.g."]
    #[doc = "    #PSA_CIPHER_OPERATION_INIT."]
    #[doc = " -# Call psa_cipher_decrypt_setup() to specify the algorithm and key."]
    #[doc = " -# Call psa_cipher_set_iv() with the IV (initialization vector) for the"]
    #[doc = "    decryption. If the IV is prepended to the ciphertext, you can call"]
    #[doc = "    psa_cipher_update() on a buffer containing the IV followed by the"]
    #[doc = "    beginning of the message."]
    #[doc = " -# Call psa_cipher_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message each time."]
    #[doc = " -# Call psa_cipher_finish()."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_cipher_decrypt_setup(),"]
    #[doc = " the operation will need to be reset by a call to psa_cipher_abort(). The"]
    #[doc = " application may call psa_cipher_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_cipher_decrypt_setup(), the application must"]
    #[doc = " eventually terminate the operation. The following events terminate an"]
    #[doc = " operation:"]
    #[doc = " - A successful call to psa_cipher_finish()."]
    #[doc = " - A call to psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set up. It must have"]
    #[doc = "                              been initialized as per the documentation for"]
    #[doc = "                              #psa_cipher_operation_t and not yet in use."]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must remain valid until the operation"]
    #[doc = "                              terminates. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_DECRYPT."]
    #[doc = " \\param alg                   The cipher algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_CIPHER(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not a cipher algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive)."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_decrypt_setup(
        operation: *mut psa_cipher_operation_t,
        key: psa_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Generate an IV for a symmetric encryption operation."]
    #[doc = ""]
    #[doc = " This function generates a random IV (initialization vector), nonce"]
    #[doc = " or initial counter value for the encryption operation as appropriate"]
    #[doc = " for the chosen algorithm, key type and key size."]
    #[doc = ""]
    #[doc = " The application must call psa_cipher_encrypt_setup() before"]
    #[doc = " calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active cipher operation."]
    #[doc = " \\param[out] iv               Buffer where the generated IV is to be written."]
    #[doc = " \\param iv_size               Size of the \\p iv buffer in bytes."]
    #[doc = " \\param[out] iv_length        On success, the number of bytes of the"]
    #[doc = "                              generated IV."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, with no IV set)."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p iv buffer is too small."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_generate_iv(
        operation: *mut psa_cipher_operation_t,
        iv: *mut u8,
        iv_size: size_t,
        iv_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the IV for a symmetric encryption or decryption operation."]
    #[doc = ""]
    #[doc = " This function sets the IV (initialization vector), nonce"]
    #[doc = " or initial counter value for the encryption or decryption operation."]
    #[doc = ""]
    #[doc = " The application must call psa_cipher_encrypt_setup() before"]
    #[doc = " calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\note When encrypting, applications should use psa_cipher_generate_iv()"]
    #[doc = " instead of this function, unless implementing a protocol that requires"]
    #[doc = " a non-random IV."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active cipher operation."]
    #[doc = " \\param[in] iv                Buffer containing the IV to use."]
    #[doc = " \\param iv_length             Size of the IV in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active cipher"]
    #[doc = "         encrypt operation, with no IV set)."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The size of \\p iv is not acceptable for the chosen algorithm,"]
    #[doc = "         or the chosen algorithm does not use an IV."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_set_iv(
        operation: *mut psa_cipher_operation_t,
        iv: *const u8,
        iv_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt or decrypt a message fragment in an active cipher operation."]
    #[doc = ""]
    #[doc = " Before calling this function, you must:"]
    #[doc = " 1. Call either psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup()."]
    #[doc = "    The choice of setup function determines whether this function"]
    #[doc = "    encrypts or decrypts its input."]
    #[doc = " 2. If the algorithm requires an IV, call psa_cipher_generate_iv()"]
    #[doc = "    (recommended when encrypting) or psa_cipher_set_iv()."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active cipher operation."]
    #[doc = " \\param[in] input             Buffer containing the message fragment to"]
    #[doc = "                              encrypt or decrypt."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] output           Buffer where the output is to be written."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, with an IV set"]
    #[doc = "         if required for the algorithm)."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p output buffer is too small."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_update(
        operation: *mut psa_cipher_operation_t,
        input: *const u8,
        input_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish encrypting or decrypting a message in a cipher operation."]
    #[doc = ""]
    #[doc = " The application must call psa_cipher_encrypt_setup() or"]
    #[doc = " psa_cipher_decrypt_setup() before calling this function. The choice"]
    #[doc = " of setup function determines whether this function encrypts or"]
    #[doc = " decrypts its input."]
    #[doc = ""]
    #[doc = " This function finishes the encryption or decryption of the message"]
    #[doc = " formed by concatenating the inputs passed to preceding calls to"]
    #[doc = " psa_cipher_update()."]
    #[doc = ""]
    #[doc = " When this function returns successfuly, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_cipher_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active cipher operation."]
    #[doc = " \\param[out] output           Buffer where the output is to be written."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total input size passed to this operation is not valid for"]
    #[doc = "         this particular algorithm. For example, the algorithm is a based"]
    #[doc = "         on block cipher and requires a whole number of blocks, but the"]
    #[doc = "         total input size is not a multiple of the block size."]
    #[doc = " \\retval #PSA_ERROR_INVALID_PADDING"]
    #[doc = "         This is a decryption operation for an algorithm that includes"]
    #[doc = "         padding, and the ciphertext does not contain valid padding."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, with an IV set"]
    #[doc = "         if required for the algorithm)."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p output buffer is too small."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_finish(
        operation: *mut psa_cipher_operation_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a cipher operation."]
    #[doc = ""]
    #[doc = " Aborting an operation frees all associated resources except for the"]
    #[doc = " \\p operation structure itself. Once aborted, the operation object"]
    #[doc = " can be reused for another operation by calling"]
    #[doc = " psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup() again."]
    #[doc = ""]
    #[doc = " You may call this function any time after the operation object has"]
    #[doc = " been initialized as described in #psa_cipher_operation_t."]
    #[doc = ""]
    #[doc = " In particular, calling psa_cipher_abort() after the operation has been"]
    #[doc = " terminated by a call to psa_cipher_abort() or psa_cipher_finish()"]
    #[doc = " is safe and has no effect."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Initialized cipher operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_cipher_abort(operation: *mut psa_cipher_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Process an authenticated encryption operation."]
    #[doc = ""]
    #[doc = " \\param key                     Identifier of the key to use for the"]
    #[doc = "                                operation. It must allow the usage"]
    #[doc = "                                #PSA_KEY_USAGE_ENCRYPT."]
    #[doc = " \\param alg                     The AEAD algorithm to compute"]
    #[doc = "                                (\\c PSA_ALG_XXX value such that"]
    #[doc = "                                #PSA_ALG_IS_AEAD(\\p alg) is true)."]
    #[doc = " \\param[in] nonce               Nonce or IV to use."]
    #[doc = " \\param nonce_length            Size of the \\p nonce buffer in bytes."]
    #[doc = " \\param[in] additional_data     Additional data that will be authenticated"]
    #[doc = "                                but not encrypted."]
    #[doc = " \\param additional_data_length  Size of \\p additional_data in bytes."]
    #[doc = " \\param[in] plaintext           Data that will be authenticated and"]
    #[doc = "                                encrypted."]
    #[doc = " \\param plaintext_length        Size of \\p plaintext in bytes."]
    #[doc = " \\param[out] ciphertext         Output buffer for the authenticated and"]
    #[doc = "                                encrypted data. The additional data is not"]
    #[doc = "                                part of this output. For algorithms where the"]
    #[doc = "                                encrypted data and the authentication tag"]
    #[doc = "                                are defined as separate outputs, the"]
    #[doc = "                                authentication tag is appended to the"]
    #[doc = "                                encrypted data."]
    #[doc = " \\param ciphertext_size         Size of the \\p ciphertext buffer in bytes."]
    #[doc = "                                This must be appropriate for the selected"]
    #[doc = "                                algorithm and key:"]
    #[doc = "                                - A sufficient output size is"]
    #[doc = "                                  #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\\c key_type,"]
    #[doc = "                                  \\p alg, \\p plaintext_length) where"]
    #[doc = "                                  \\c key_type is the type of \\p key."]
    #[doc = "                                - #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\\p"]
    #[doc = "                                  plaintext_length) evaluates to the maximum"]
    #[doc = "                                  ciphertext size of any supported AEAD"]
    #[doc = "                                  encryption."]
    #[doc = " \\param[out] ciphertext_length  On success, the size of the output"]
    #[doc = "                                in the \\p ciphertext buffer."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not an AEAD algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         \\p ciphertext_size is too small."]
    #[doc = "         #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\\c key_type, \\p alg,"]
    #[doc = "         \\p plaintext_length) or"]
    #[doc = "         #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\\p plaintext_length) can be used to"]
    #[doc = "         determine the required buffer size."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_encrypt(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        nonce: *const u8,
        nonce_length: size_t,
        additional_data: *const u8,
        additional_data_length: size_t,
        plaintext: *const u8,
        plaintext_length: size_t,
        ciphertext: *mut u8,
        ciphertext_size: size_t,
        ciphertext_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Process an authenticated decryption operation."]
    #[doc = ""]
    #[doc = " \\param key                     Identifier of the key to use for the"]
    #[doc = "                                operation. It must allow the usage"]
    #[doc = "                                #PSA_KEY_USAGE_DECRYPT."]
    #[doc = " \\param alg                     The AEAD algorithm to compute"]
    #[doc = "                                (\\c PSA_ALG_XXX value such that"]
    #[doc = "                                #PSA_ALG_IS_AEAD(\\p alg) is true)."]
    #[doc = " \\param[in] nonce               Nonce or IV to use."]
    #[doc = " \\param nonce_length            Size of the \\p nonce buffer in bytes."]
    #[doc = " \\param[in] additional_data     Additional data that has been authenticated"]
    #[doc = "                                but not encrypted."]
    #[doc = " \\param additional_data_length  Size of \\p additional_data in bytes."]
    #[doc = " \\param[in] ciphertext          Data that has been authenticated and"]
    #[doc = "                                encrypted. For algorithms where the"]
    #[doc = "                                encrypted data and the authentication tag"]
    #[doc = "                                are defined as separate inputs, the buffer"]
    #[doc = "                                must contain the encrypted data followed"]
    #[doc = "                                by the authentication tag."]
    #[doc = " \\param ciphertext_length       Size of \\p ciphertext in bytes."]
    #[doc = " \\param[out] plaintext          Output buffer for the decrypted data."]
    #[doc = " \\param plaintext_size          Size of the \\p plaintext buffer in bytes."]
    #[doc = "                                This must be appropriate for the selected"]
    #[doc = "                                algorithm and key:"]
    #[doc = "                                - A sufficient output size is"]
    #[doc = "                                  #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\\c key_type,"]
    #[doc = "                                  \\p alg, \\p ciphertext_length) where"]
    #[doc = "                                  \\c key_type is the type of \\p key."]
    #[doc = "                                - #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\\p"]
    #[doc = "                                  ciphertext_length) evaluates to the maximum"]
    #[doc = "                                  plaintext size of any supported AEAD"]
    #[doc = "                                  decryption."]
    #[doc = " \\param[out] plaintext_length   On success, the size of the output"]
    #[doc = "                                in the \\p plaintext buffer."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The ciphertext is not authentic."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not an AEAD algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         \\p plaintext_size is too small."]
    #[doc = "         #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\\c key_type, \\p alg,"]
    #[doc = "         \\p ciphertext_length) or"]
    #[doc = "         #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\\p ciphertext_length) can be used"]
    #[doc = "         to determine the required buffer size."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_decrypt(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        nonce: *const u8,
        nonce_length: size_t,
        additional_data: *const u8,
        additional_data_length: size_t,
        ciphertext: *const u8,
        ciphertext_length: size_t,
        plaintext: *mut u8,
        plaintext_size: size_t,
        plaintext_length: *mut size_t,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart AEAD operations."]
#[doc = ""]
#[doc = " Before calling any function on an AEAD operation object, the application"]
#[doc = " must initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_aead_operation_t operation;"]
#[doc = "   memset(&operation, 0, sizeof(operation));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_aead_operation_t operation = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_AEAD_OPERATION_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_aead_operation_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_aead_operation_t operation;"]
#[doc = "   operation = psa_aead_operation_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_aead_operation_t = psa_aead_operation_s;
extern "C" {
    #[doc = " Set the key for a multipart authenticated encryption operation."]
    #[doc = ""]
    #[doc = " The sequence of operations to encrypt a message with authentication"]
    #[doc = " is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_aead_operation_t, e.g."]
    #[doc = "    #PSA_AEAD_OPERATION_INIT."]
    #[doc = " -# Call psa_aead_encrypt_setup() to specify the algorithm and key."]
    #[doc = " -# If needed, call psa_aead_set_lengths() to specify the length of the"]
    #[doc = "    inputs to the subsequent calls to psa_aead_update_ad() and"]
    #[doc = "    psa_aead_update(). See the documentation of psa_aead_set_lengths()"]
    #[doc = "    for details."]
    #[doc = " -# Call either psa_aead_generate_nonce() or psa_aead_set_nonce() to"]
    #[doc = "    generate or set the nonce. You should use"]
    #[doc = "    psa_aead_generate_nonce() unless the protocol you are implementing"]
    #[doc = "    requires a specific nonce value."]
    #[doc = " -# Call psa_aead_update_ad() zero, one or more times, passing a fragment"]
    #[doc = "    of the non-encrypted additional authenticated data each time."]
    #[doc = " -# Call psa_aead_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the message to encrypt each time."]
    #[doc = " -# Call psa_aead_finish()."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_aead_encrypt_setup(),"]
    #[doc = " the operation will need to be reset by a call to psa_aead_abort(). The"]
    #[doc = " application may call psa_aead_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_aead_encrypt_setup(), the application must"]
    #[doc = " eventually terminate the operation. The following events terminate an"]
    #[doc = " operation:"]
    #[doc = " - A successful call to psa_aead_finish()."]
    #[doc = " - A call to psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set up. It must have"]
    #[doc = "                              been initialized as per the documentation for"]
    #[doc = "                              #psa_aead_operation_t and not yet in use."]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must remain valid until the operation"]
    #[doc = "                              terminates. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_ENCRYPT."]
    #[doc = " \\param alg                   The AEAD algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_AEAD(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive)."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not an AEAD algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_encrypt_setup(
        operation: *mut psa_aead_operation_t,
        key: psa_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the key for a multipart authenticated decryption operation."]
    #[doc = ""]
    #[doc = " The sequence of operations to decrypt a message with authentication"]
    #[doc = " is as follows:"]
    #[doc = " -# Allocate an operation object which will be passed to all the functions"]
    #[doc = "    listed here."]
    #[doc = " -# Initialize the operation object with one of the methods described in the"]
    #[doc = "    documentation for #psa_aead_operation_t, e.g."]
    #[doc = "    #PSA_AEAD_OPERATION_INIT."]
    #[doc = " -# Call psa_aead_decrypt_setup() to specify the algorithm and key."]
    #[doc = " -# If needed, call psa_aead_set_lengths() to specify the length of the"]
    #[doc = "    inputs to the subsequent calls to psa_aead_update_ad() and"]
    #[doc = "    psa_aead_update(). See the documentation of psa_aead_set_lengths()"]
    #[doc = "    for details."]
    #[doc = " -# Call psa_aead_set_nonce() with the nonce for the decryption."]
    #[doc = " -# Call psa_aead_update_ad() zero, one or more times, passing a fragment"]
    #[doc = "    of the non-encrypted additional authenticated data each time."]
    #[doc = " -# Call psa_aead_update() zero, one or more times, passing a fragment"]
    #[doc = "    of the ciphertext to decrypt each time."]
    #[doc = " -# Call psa_aead_verify()."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_aead_decrypt_setup(),"]
    #[doc = " the operation will need to be reset by a call to psa_aead_abort(). The"]
    #[doc = " application may call psa_aead_abort() at any time after the operation"]
    #[doc = " has been initialized."]
    #[doc = ""]
    #[doc = " After a successful call to psa_aead_decrypt_setup(), the application must"]
    #[doc = " eventually terminate the operation. The following events terminate an"]
    #[doc = " operation:"]
    #[doc = " - A successful call to psa_aead_verify()."]
    #[doc = " - A call to psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     The operation object to set up. It must have"]
    #[doc = "                              been initialized as per the documentation for"]
    #[doc = "                              #psa_aead_operation_t and not yet in use."]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must remain valid until the operation"]
    #[doc = "                              terminates. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_DECRYPT."]
    #[doc = " \\param alg                   The AEAD algorithm to compute"]
    #[doc = "                              (\\c PSA_ALG_XXX value such that"]
    #[doc = "                              #PSA_ALG_IS_AEAD(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive)."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p key is not compatible with \\p alg."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not supported or is not an AEAD algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_decrypt_setup(
        operation: *mut psa_aead_operation_t,
        key: psa_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Generate a random nonce for an authenticated encryption operation."]
    #[doc = ""]
    #[doc = " This function generates a random nonce for the authenticated encryption"]
    #[doc = " operation with an appropriate size for the chosen algorithm, key type"]
    #[doc = " and key size."]
    #[doc = ""]
    #[doc = " The application must call psa_aead_encrypt_setup() before"]
    #[doc = " calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[out] nonce            Buffer where the generated nonce is to be"]
    #[doc = "                              written."]
    #[doc = " \\param nonce_size            Size of the \\p nonce buffer in bytes."]
    #[doc = " \\param[out] nonce_length     On success, the number of bytes of the"]
    #[doc = "                              generated nonce."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active aead encrypt"]
    #[doc = "         operation, with no nonce set)."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p nonce buffer is too small."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_generate_nonce(
        operation: *mut psa_aead_operation_t,
        nonce: *mut u8,
        nonce_size: size_t,
        nonce_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the nonce for an authenticated encryption or decryption operation."]
    #[doc = ""]
    #[doc = " This function sets the nonce for the authenticated"]
    #[doc = " encryption or decryption operation."]
    #[doc = ""]
    #[doc = " The application must call psa_aead_encrypt_setup() or"]
    #[doc = " psa_aead_decrypt_setup() before calling this function."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\note When encrypting, applications should use psa_aead_generate_nonce()"]
    #[doc = " instead of this function, unless implementing a protocol that requires"]
    #[doc = " a non-random IV."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[in] nonce             Buffer containing the nonce to use."]
    #[doc = " \\param nonce_length          Size of the nonce in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, with no nonce"]
    #[doc = "         set)."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The size of \\p nonce is not acceptable for the chosen algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_set_nonce(
        operation: *mut psa_aead_operation_t,
        nonce: *const u8,
        nonce_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Declare the lengths of the message and additional data for AEAD."]
    #[doc = ""]
    #[doc = " The application must call this function before calling"]
    #[doc = " psa_aead_update_ad() or psa_aead_update() if the algorithm for"]
    #[doc = " the operation requires it. If the algorithm does not require it,"]
    #[doc = " calling this function is optional, but if this function is called"]
    #[doc = " then the implementation must enforce the lengths."]
    #[doc = ""]
    #[doc = " You may call this function before or after setting the nonce with"]
    #[doc = " psa_aead_set_nonce() or psa_aead_generate_nonce()."]
    #[doc = ""]
    #[doc = " - For #PSA_ALG_CCM, calling this function is required."]
    #[doc = " - For the other AEAD algorithms defined in this specification, calling"]
    #[doc = "   this function is not required."]
    #[doc = " - For vendor-defined algorithm, refer to the vendor documentation."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param ad_length             Size of the non-encrypted additional"]
    #[doc = "                              authenticated data in bytes."]
    #[doc = " \\param plaintext_length      Size of the plaintext to encrypt in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, and"]
    #[doc = "         psa_aead_update_ad() and psa_aead_update() must not have been"]
    #[doc = "         called yet)."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         At least one of the lengths is not acceptable for the chosen"]
    #[doc = "         algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_set_lengths(
        operation: *mut psa_aead_operation_t,
        ad_length: size_t,
        plaintext_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Pass additional data to an active AEAD operation."]
    #[doc = ""]
    #[doc = " Additional data is authenticated, but not encrypted."]
    #[doc = ""]
    #[doc = " You may call this function multiple times to pass successive fragments"]
    #[doc = " of the additional data. You may not call this function after passing"]
    #[doc = " data to encrypt or decrypt with psa_aead_update()."]
    #[doc = ""]
    #[doc = " Before calling this function, you must:"]
    #[doc = " 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup()."]
    #[doc = " 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce()."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,"]
    #[doc = "          there is no guarantee that the input is valid. Therefore, until"]
    #[doc = "          you have called psa_aead_verify() and it has returned #PSA_SUCCESS,"]
    #[doc = "          treat the input as untrusted and prepare to undo any action that"]
    #[doc = "          depends on the input if psa_aead_verify() returns an error status."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[in] input             Buffer containing the fragment of"]
    #[doc = "                              additional data."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, have a nonce"]
    #[doc = "         set, have lengths set if required by the algorithm, and"]
    #[doc = "         psa_aead_update() must not have been called yet)."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total input length overflows the additional data length that"]
    #[doc = "         was previously specified with psa_aead_set_lengths()."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_update_ad(
        operation: *mut psa_aead_operation_t,
        input: *const u8,
        input_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt or decrypt a message fragment in an active AEAD operation."]
    #[doc = ""]
    #[doc = " Before calling this function, you must:"]
    #[doc = " 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup()."]
    #[doc = "    The choice of setup function determines whether this function"]
    #[doc = "    encrypts or decrypts its input."]
    #[doc = " 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce()."]
    #[doc = " 3. Call psa_aead_update_ad() to pass all the additional data."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,"]
    #[doc = "          there is no guarantee that the input is valid. Therefore, until"]
    #[doc = "          you have called psa_aead_verify() and it has returned #PSA_SUCCESS:"]
    #[doc = "          - Do not use the output in any way other than storing it in a"]
    #[doc = "            confidential location. If you take any action that depends"]
    #[doc = "            on the tentative decrypted data, this action will need to be"]
    #[doc = "            undone if the input turns out not to be valid. Furthermore,"]
    #[doc = "            if an adversary can observe that this action took place"]
    #[doc = "            (for example through timing), they may be able to use this"]
    #[doc = "            fact as an oracle to decrypt any message encrypted with the"]
    #[doc = "            same key."]
    #[doc = "          - In particular, do not copy the output anywhere but to a"]
    #[doc = "            memory or storage space that you have exclusive access to."]
    #[doc = ""]
    #[doc = " This function does not require the input to be aligned to any"]
    #[doc = " particular block boundary. If the implementation can only process"]
    #[doc = " a whole block at a time, it must consume all the input provided, but"]
    #[doc = " it may delay the end of the corresponding output until a subsequent"]
    #[doc = " call to psa_aead_update(), psa_aead_finish() or psa_aead_verify()"]
    #[doc = " provides sufficient input. The amount of data that can be delayed"]
    #[doc = " in this way is bounded by #PSA_AEAD_UPDATE_OUTPUT_SIZE."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[in] input             Buffer containing the message fragment to"]
    #[doc = "                              encrypt or decrypt."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] output           Buffer where the output is to be written."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = "                              This must be appropriate for the selected"]
    #[doc = "                                algorithm and key:"]
    #[doc = "                                - A sufficient output size is"]
    #[doc = "                                  #PSA_AEAD_UPDATE_OUTPUT_SIZE(\\c key_type,"]
    #[doc = "                                  \\c alg, \\p input_length) where"]
    #[doc = "                                  \\c key_type is the type of key and \\c alg is"]
    #[doc = "                                  the algorithm that were used to set up the"]
    #[doc = "                                  operation."]
    #[doc = "                                - #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\\p"]
    #[doc = "                                  input_length) evaluates to the maximum"]
    #[doc = "                                  output size of any supported AEAD"]
    #[doc = "                                  algorithm."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active, have a nonce"]
    #[doc = "         set, and have lengths set if required by the algorithm)."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p output buffer is too small."]
    #[doc = "         #PSA_AEAD_UPDATE_OUTPUT_SIZE(\\c key_type, \\c alg, \\p input_length) or"]
    #[doc = "         #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\\p input_length) can be used to"]
    #[doc = "         determine the required buffer size."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total length of input to psa_aead_update_ad() so far is"]
    #[doc = "         less than the additional data length that was previously"]
    #[doc = "         specified with psa_aead_set_lengths()."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total input length overflows the plaintext length that"]
    #[doc = "         was previously specified with psa_aead_set_lengths()."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_update(
        operation: *mut psa_aead_operation_t,
        input: *const u8,
        input_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish encrypting a message in an AEAD operation."]
    #[doc = ""]
    #[doc = " The operation must have been set up with psa_aead_encrypt_setup()."]
    #[doc = ""]
    #[doc = " This function finishes the authentication of the additional data"]
    #[doc = " formed by concatenating the inputs passed to preceding calls to"]
    #[doc = " psa_aead_update_ad() with the plaintext formed by concatenating the"]
    #[doc = " inputs passed to preceding calls to psa_aead_update()."]
    #[doc = ""]
    #[doc = " This function has two output buffers:"]
    #[doc = " - \\p ciphertext contains trailing ciphertext that was buffered from"]
    #[doc = "   preceding calls to psa_aead_update()."]
    #[doc = " - \\p tag contains the authentication tag."]
    #[doc = ""]
    #[doc = " When this function returns successfuly, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[out] ciphertext       Buffer where the last part of the ciphertext"]
    #[doc = "                              is to be written."]
    #[doc = " \\param ciphertext_size       Size of the \\p ciphertext buffer in bytes."]
    #[doc = "                              This must be appropriate for the selected"]
    #[doc = "                              algorithm and key:"]
    #[doc = "                              - A sufficient output size is"]
    #[doc = "                                #PSA_AEAD_FINISH_OUTPUT_SIZE(\\c key_type,"]
    #[doc = "                                \\c alg) where \\c key_type is the type of key"]
    #[doc = "                                and \\c alg is the algorithm that were used to"]
    #[doc = "                                set up the operation."]
    #[doc = "                              - #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE evaluates to"]
    #[doc = "                                the maximum output size of any supported AEAD"]
    #[doc = "                                algorithm."]
    #[doc = " \\param[out] ciphertext_length On success, the number of bytes of"]
    #[doc = "                              returned ciphertext."]
    #[doc = " \\param[out] tag              Buffer where the authentication tag is"]
    #[doc = "                              to be written."]
    #[doc = " \\param tag_size              Size of the \\p tag buffer in bytes."]
    #[doc = "                              This must be appropriate for the selected"]
    #[doc = "                              algorithm and key:"]
    #[doc = "                              - The exact tag size is #PSA_AEAD_TAG_LENGTH(\\c"]
    #[doc = "                                key_type, \\c key_bits, \\c alg) where"]
    #[doc = "                                \\c key_type and \\c key_bits are the type and"]
    #[doc = "                                bit-size of the key, and \\c alg is the"]
    #[doc = "                                algorithm that were used in the call to"]
    #[doc = "                                psa_aead_encrypt_setup()."]
    #[doc = "                              - #PSA_AEAD_TAG_MAX_SIZE evaluates to the"]
    #[doc = "                                maximum tag size of any supported AEAD"]
    #[doc = "                                algorithm."]
    #[doc = " \\param[out] tag_length       On success, the number of bytes"]
    #[doc = "                              that make up the returned tag."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active encryption"]
    #[doc = "         operation with a nonce set)."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p ciphertext or \\p tag buffer is too small."]
    #[doc = "         #PSA_AEAD_FINISH_OUTPUT_SIZE(\\c key_type, \\c alg) or"]
    #[doc = "         #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE can be used to determine the"]
    #[doc = "         required \\p ciphertext buffer size. #PSA_AEAD_TAG_LENGTH(\\c key_type,"]
    #[doc = "         \\c key_bits, \\c alg) or #PSA_AEAD_TAG_MAX_SIZE can be used to"]
    #[doc = "         determine the required \\p tag buffer size."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total length of input to psa_aead_update_ad() so far is"]
    #[doc = "         less than the additional data length that was previously"]
    #[doc = "         specified with psa_aead_set_lengths()."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total length of input to psa_aead_update() so far is"]
    #[doc = "         less than the plaintext length that was previously"]
    #[doc = "         specified with psa_aead_set_lengths()."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_finish(
        operation: *mut psa_aead_operation_t,
        ciphertext: *mut u8,
        ciphertext_size: size_t,
        ciphertext_length: *mut size_t,
        tag: *mut u8,
        tag_size: size_t,
        tag_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish authenticating and decrypting a message in an AEAD operation."]
    #[doc = ""]
    #[doc = " The operation must have been set up with psa_aead_decrypt_setup()."]
    #[doc = ""]
    #[doc = " This function finishes the authenticated decryption of the message"]
    #[doc = " components:"]
    #[doc = ""]
    #[doc = " -  The additional data consisting of the concatenation of the inputs"]
    #[doc = "    passed to preceding calls to psa_aead_update_ad()."]
    #[doc = " -  The ciphertext consisting of the concatenation of the inputs passed to"]
    #[doc = "    preceding calls to psa_aead_update()."]
    #[doc = " -  The tag passed to this function call."]
    #[doc = ""]
    #[doc = " If the authentication tag is correct, this function outputs any remaining"]
    #[doc = " plaintext and reports success. If the authentication tag is not correct,"]
    #[doc = " this function returns #PSA_ERROR_INVALID_SIGNATURE."]
    #[doc = ""]
    #[doc = " When this function returns successfuly, the operation becomes inactive."]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_aead_abort()."]
    #[doc = ""]
    #[doc = " \\note Implementations shall make the best effort to ensure that the"]
    #[doc = " comparison between the actual tag and the expected tag is performed"]
    #[doc = " in constant time."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Active AEAD operation."]
    #[doc = " \\param[out] plaintext        Buffer where the last part of the plaintext"]
    #[doc = "                              is to be written. This is the remaining data"]
    #[doc = "                              from previous calls to psa_aead_update()"]
    #[doc = "                              that could not be processed until the end"]
    #[doc = "                              of the input."]
    #[doc = " \\param plaintext_size        Size of the \\p plaintext buffer in bytes."]
    #[doc = "                              This must be appropriate for the selected algorithm and key:"]
    #[doc = "                              - A sufficient output size is"]
    #[doc = "                                #PSA_AEAD_VERIFY_OUTPUT_SIZE(\\c key_type,"]
    #[doc = "                                \\c alg) where \\c key_type is the type of key"]
    #[doc = "                                and \\c alg is the algorithm that were used to"]
    #[doc = "                                set up the operation."]
    #[doc = "                              - #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE evaluates to"]
    #[doc = "                                the maximum output size of any supported AEAD"]
    #[doc = "                                algorithm."]
    #[doc = " \\param[out] plaintext_length On success, the number of bytes of"]
    #[doc = "                              returned plaintext."]
    #[doc = " \\param[in] tag               Buffer containing the authentication tag."]
    #[doc = " \\param tag_length            Size of the \\p tag buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The calculations were successful, but the authentication tag is"]
    #[doc = "         not correct."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be an active decryption"]
    #[doc = "         operation with a nonce set)."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p plaintext buffer is too small."]
    #[doc = "         #PSA_AEAD_VERIFY_OUTPUT_SIZE(\\c key_type, \\c alg) or"]
    #[doc = "         #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE can be used to determine the"]
    #[doc = "         required buffer size."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total length of input to psa_aead_update_ad() so far is"]
    #[doc = "         less than the additional data length that was previously"]
    #[doc = "         specified with psa_aead_set_lengths()."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The total length of input to psa_aead_update() so far is"]
    #[doc = "         less than the plaintext length that was previously"]
    #[doc = "         specified with psa_aead_set_lengths()."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_verify(
        operation: *mut psa_aead_operation_t,
        plaintext: *mut u8,
        plaintext_size: size_t,
        plaintext_length: *mut size_t,
        tag: *const u8,
        tag_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort an AEAD operation."]
    #[doc = ""]
    #[doc = " Aborting an operation frees all associated resources except for the"]
    #[doc = " \\p operation structure itself. Once aborted, the operation object"]
    #[doc = " can be reused for another operation by calling"]
    #[doc = " psa_aead_encrypt_setup() or psa_aead_decrypt_setup() again."]
    #[doc = ""]
    #[doc = " You may call this function any time after the operation object has"]
    #[doc = " been initialized as described in #psa_aead_operation_t."]
    #[doc = ""]
    #[doc = " In particular, calling psa_aead_abort() after the operation has been"]
    #[doc = " terminated by a call to psa_aead_abort(), psa_aead_finish() or"]
    #[doc = " psa_aead_verify() is safe and has no effect."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation     Initialized AEAD operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_aead_abort(operation: *mut psa_aead_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Sign a message with a private key. For hash-and-sign algorithms,"]
    #[doc = "        this includes the hashing step."]
    #[doc = ""]
    #[doc = " \\note To perform a multi-part hash-and-sign signature algorithm, first use"]
    #[doc = "       a multi-part hash operation and then pass the resulting hash to"]
    #[doc = "       psa_sign_hash(). PSA_ALG_GET_HASH(\\p alg) can be used to determine the"]
    #[doc = "       hash algorithm to use."]
    #[doc = ""]
    #[doc = " \\param[in]  key              Identifier of the key to use for the operation."]
    #[doc = "                              It must be an asymmetric key pair. The key must"]
    #[doc = "                              allow the usage #PSA_KEY_USAGE_SIGN_MESSAGE."]
    #[doc = " \\param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX"]
    #[doc = "                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\\p alg)"]
    #[doc = "                              is true), that is compatible with the type of"]
    #[doc = "                              \\p key."]
    #[doc = " \\param[in]  input            The input message to sign."]
    #[doc = " \\param[in]  input_length     Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] signature        Buffer where the signature is to be written."]
    #[doc = " \\param[in]  signature_size   Size of the \\p signature buffer in bytes. This"]
    #[doc = "                              must be appropriate for the selected"]
    #[doc = "                              algorithm and key:"]
    #[doc = "                              - The required signature size is"]
    #[doc = "                                #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)"]
    #[doc = "                                where \\c key_type and \\c key_bits are the type and"]
    #[doc = "                                bit-size respectively of key."]
    #[doc = "                              - #PSA_SIGNATURE_MAX_SIZE evaluates to the"]
    #[doc = "                                maximum signature size of any supported"]
    #[doc = "                                signature algorithm."]
    #[doc = " \\param[out] signature_length On success, the number of bytes that make up"]
    #[doc = "                              the returned signature value."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,"]
    #[doc = "         or it does not permit the requested algorithm."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p signature buffer is too small. You can"]
    #[doc = "         determine a sufficient buffer size by calling"]
    #[doc = "         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)"]
    #[doc = "         where \\c key_type and \\c key_bits are the type and bit-size"]
    #[doc = "         respectively of \\p key."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_sign_message(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        signature: *mut u8,
        signature_size: size_t,
        signature_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Verify the signature of a message with a public key, using"]
    #[doc = "         a hash-and-sign verification algorithm."]
    #[doc = ""]
    #[doc = " \\note To perform a multi-part hash-and-sign signature verification"]
    #[doc = "       algorithm, first use a multi-part hash operation to hash the message"]
    #[doc = "       and then pass the resulting hash to psa_verify_hash()."]
    #[doc = "       PSA_ALG_GET_HASH(\\p alg) can be used to determine the hash algorithm"]
    #[doc = "       to use."]
    #[doc = ""]
    #[doc = " \\param[in]  key              Identifier of the key to use for the operation."]
    #[doc = "                              It must be a public key or an asymmetric key"]
    #[doc = "                              pair. The key must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_VERIFY_MESSAGE."]
    #[doc = " \\param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX"]
    #[doc = "                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\\p alg)"]
    #[doc = "                              is true), that is compatible with the type of"]
    #[doc = "                              \\p key."]
    #[doc = " \\param[in]  input            The message whose signature is to be verified."]
    #[doc = " \\param[in]  input_length     Size of the \\p input buffer in bytes."]
    #[doc = " \\param[out] signature        Buffer containing the signature to verify."]
    #[doc = " \\param[in]  signature_length Size of the \\p signature buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,"]
    #[doc = "         or it does not permit the requested algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The calculation was performed successfully, but the passed signature"]
    #[doc = "         is not a valid signature."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_verify_message(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        signature: *const u8,
        signature_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Sign a hash or short message with a private key."]
    #[doc = ""]
    #[doc = " Note that to perform a hash-and-sign signature algorithm, you must"]
    #[doc = " first calculate the hash by calling psa_hash_setup(), psa_hash_update()"]
    #[doc = " and psa_hash_finish(), or alternatively by calling psa_hash_compute()."]
    #[doc = " Then pass the resulting hash as the \\p hash"]
    #[doc = " parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\\p alg)"]
    #[doc = " to determine the hash algorithm to use."]
    #[doc = ""]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must be an asymmetric key pair. The key must"]
    #[doc = "                              allow the usage #PSA_KEY_USAGE_SIGN_HASH."]
    #[doc = " \\param alg                   A signature algorithm (PSA_ALG_XXX"]
    #[doc = "                              value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)"]
    #[doc = "                              is true), that is compatible with"]
    #[doc = "                              the type of \\p key."]
    #[doc = " \\param[in] hash              The hash or message to sign."]
    #[doc = " \\param hash_length           Size of the \\p hash buffer in bytes."]
    #[doc = " \\param[out] signature        Buffer where the signature is to be written."]
    #[doc = " \\param signature_size        Size of the \\p signature buffer in bytes."]
    #[doc = " \\param[out] signature_length On success, the number of bytes"]
    #[doc = "                              that make up the returned signature value."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p signature buffer is too small. You can"]
    #[doc = "         determine a sufficient buffer size by calling"]
    #[doc = "         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)"]
    #[doc = "         where \\c key_type and \\c key_bits are the type and bit-size"]
    #[doc = "         respectively of \\p key."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_sign_hash(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: size_t,
        signature: *mut u8,
        signature_size: size_t,
        signature_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Verify the signature of a hash or short message using a public key."]
    #[doc = ""]
    #[doc = " Note that to perform a hash-and-sign signature algorithm, you must"]
    #[doc = " first calculate the hash by calling psa_hash_setup(), psa_hash_update()"]
    #[doc = " and psa_hash_finish(), or alternatively by calling psa_hash_compute()."]
    #[doc = " Then pass the resulting hash as the \\p hash"]
    #[doc = " parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\\p alg)"]
    #[doc = " to determine the hash algorithm to use."]
    #[doc = ""]
    #[doc = " \\param key               Identifier of the key to use for the operation. It"]
    #[doc = "                          must be a public key or an asymmetric key pair. The"]
    #[doc = "                          key must allow the usage"]
    #[doc = "                          #PSA_KEY_USAGE_VERIFY_HASH."]
    #[doc = " \\param alg               A signature algorithm (PSA_ALG_XXX"]
    #[doc = "                          value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)"]
    #[doc = "                          is true), that is compatible with"]
    #[doc = "                          the type of \\p key."]
    #[doc = " \\param[in] hash          The hash or message whose signature is to be"]
    #[doc = "                          verified."]
    #[doc = " \\param hash_length       Size of the \\p hash buffer in bytes."]
    #[doc = " \\param[in] signature     Buffer containing the signature to verify."]
    #[doc = " \\param signature_length  Size of the \\p signature buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         The signature is valid."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The calculation was perfomed successfully, but the passed"]
    #[doc = "         signature is not a valid signature."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_verify_hash(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: size_t,
        signature: *const u8,
        signature_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Encrypt a short message with a public key."]
    #[doc = ""]
    #[doc = " \\param key                   Identifer of the key to use for the operation."]
    #[doc = "                              It must be a public key or an asymmetric key"]
    #[doc = "                              pair. It must allow the usage"]
    #[doc = "                              #PSA_KEY_USAGE_ENCRYPT."]
    #[doc = " \\param alg                   An asymmetric encryption algorithm that is"]
    #[doc = "                              compatible with the type of \\p key."]
    #[doc = " \\param[in] input             The message to encrypt."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[in] salt              A salt or label, if supported by the"]
    #[doc = "                              encryption algorithm."]
    #[doc = "                              If the algorithm does not support a"]
    #[doc = "                              salt, pass \\c NULL."]
    #[doc = "                              If the algorithm supports an optional"]
    #[doc = "                              salt and you do not want to pass a salt,"]
    #[doc = "                              pass \\c NULL."]
    #[doc = ""]
    #[doc = "                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is"]
    #[doc = "                                supported."]
    #[doc = " \\param salt_length           Size of the \\p salt buffer in bytes."]
    #[doc = "                              If \\p salt is \\c NULL, pass 0."]
    #[doc = " \\param[out] output           Buffer where the encrypted message is to"]
    #[doc = "                              be written."]
    #[doc = " \\param output_size           Size of the \\p output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p output buffer is too small. You can"]
    #[doc = "         determine a sufficient buffer size by calling"]
    #[doc = "         #PSA_ASYMMETRIC_ENCRYPT_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)"]
    #[doc = "         where \\c key_type and \\c key_bits are the type and bit-size"]
    #[doc = "         respectively of \\p key."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_asymmetric_encrypt(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        salt: *const u8,
        salt_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Decrypt a short message with a private key."]
    #[doc = ""]
    #[doc = " \\param key                   Identifier of the key to use for the operation."]
    #[doc = "                              It must be an asymmetric key pair. It must"]
    #[doc = "                              allow the usage #PSA_KEY_USAGE_DECRYPT."]
    #[doc = " \\param alg                   An asymmetric encryption algorithm that is"]
    #[doc = "                              compatible with the type of \\p key."]
    #[doc = " \\param[in] input             The message to decrypt."]
    #[doc = " \\param input_length          Size of the \\p input buffer in bytes."]
    #[doc = " \\param[in] salt              A salt or label, if supported by the"]
    #[doc = "                              encryption algorithm."]
    #[doc = "                              If the algorithm does not support a"]
    #[doc = "                              salt, pass \\c NULL."]
    #[doc = "                              If the algorithm supports an optional"]
    #[doc = "                              salt and you do not want to pass a salt,"]
    #[doc = "                              pass \\c NULL."]
    #[doc = ""]
    #[doc = "                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is"]
    #[doc = "                                supported."]
    #[doc = " \\param salt_length           Size of the \\p salt buffer in bytes."]
    #[doc = "                              If \\p salt is \\c NULL, pass 0."]
    #[doc = " \\param[out] output           Buffer where the decrypted message is to"]
    #[doc = "                              be written."]
    #[doc = " \\param output_size           Size of the \\c output buffer in bytes."]
    #[doc = " \\param[out] output_length    On success, the number of bytes"]
    #[doc = "                              that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         The size of the \\p output buffer is too small. You can"]
    #[doc = "         determine a sufficient buffer size by calling"]
    #[doc = "         #PSA_ASYMMETRIC_DECRYPT_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)"]
    #[doc = "         where \\c key_type and \\c key_bits are the type and bit-size"]
    #[doc = "         respectively of \\p key."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY"]
    #[doc = " \\retval #PSA_ERROR_INVALID_PADDING"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_asymmetric_decrypt(
        key: psa_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: size_t,
        salt: *const u8,
        salt_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for key derivation operations."]
#[doc = ""]
#[doc = " Before calling any function on a key derivation operation object, the"]
#[doc = " application must initialize it by any of the following means:"]
#[doc = " - Set the structure to all-bits-zero, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_derivation_operation_t operation;"]
#[doc = "   memset(&operation, 0, sizeof(operation));"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to logical zero values, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_derivation_operation_t operation = {0};"]
#[doc = "   \\endcode"]
#[doc = " - Initialize the structure to the initializer #PSA_KEY_DERIVATION_OPERATION_INIT,"]
#[doc = "   for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_derivation_operation_t operation = PSA_KEY_DERIVATION_OPERATION_INIT;"]
#[doc = "   \\endcode"]
#[doc = " - Assign the result of the function psa_key_derivation_operation_init()"]
#[doc = "   to the structure, for example:"]
#[doc = "   \\code"]
#[doc = "   psa_key_derivation_operation_t operation;"]
#[doc = "   operation = psa_key_derivation_operation_init();"]
#[doc = "   \\endcode"]
#[doc = ""]
#[doc = " This is an implementation-defined \\c struct. Applications should not"]
#[doc = " make any assumptions about the content of this structure."]
#[doc = " Implementation details can change in future versions without notice."]
pub type psa_key_derivation_operation_t = psa_key_derivation_s;
extern "C" {
    #[doc = " Set up a key derivation operation."]
    #[doc = ""]
    #[doc = " A key derivation algorithm takes some inputs and uses them to generate"]
    #[doc = " a byte stream in a deterministic way."]
    #[doc = " This byte stream can be used to produce keys and other"]
    #[doc = " cryptographic material."]
    #[doc = ""]
    #[doc = " To derive a key:"]
    #[doc = " -# Start with an initialized object of type #psa_key_derivation_operation_t."]
    #[doc = " -# Call psa_key_derivation_setup() to select the algorithm."]
    #[doc = " -# Provide the inputs for the key derivation by calling"]
    #[doc = "    psa_key_derivation_input_bytes() or psa_key_derivation_input_key()"]
    #[doc = "    as appropriate. Which inputs are needed, in what order, and whether"]
    #[doc = "    they may be keys and if so of what type depends on the algorithm."]
    #[doc = " -# Optionally set the operation's maximum capacity with"]
    #[doc = "    psa_key_derivation_set_capacity(). You may do this before, in the middle"]
    #[doc = "    of or after providing inputs. For some algorithms, this step is mandatory"]
    #[doc = "    because the output depends on the maximum capacity."]
    #[doc = " -# To derive a key, call psa_key_derivation_output_key()."]
    #[doc = "    To derive a byte string for a different purpose, call"]
    #[doc = "    psa_key_derivation_output_bytes()."]
    #[doc = "    Successive calls to these functions use successive output bytes"]
    #[doc = "    calculated by the key derivation algorithm."]
    #[doc = " -# Clean up the key derivation operation object with"]
    #[doc = "    psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " If this function returns an error, the key derivation operation object is"]
    #[doc = " not changed."]
    #[doc = ""]
    #[doc = " If an error occurs at any step after a call to psa_key_derivation_setup(),"]
    #[doc = " the operation will need to be reset by a call to psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " Implementations must reject an attempt to derive a key of size 0."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation       The key derivation operation object"]
    #[doc = "                                to set up. It must"]
    #[doc = "                                have been initialized but not set up yet."]
    #[doc = " \\param alg                     The key derivation algorithm to compute"]
    #[doc = "                                (\\c PSA_ALG_XXX value such that"]
    #[doc = "                                #PSA_ALG_IS_KEY_DERIVATION(\\p alg) is true)."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c alg is not a key derivation algorithm."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\c alg is not supported or is not a key derivation algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be inactive)."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_setup(
        operation: *mut psa_key_derivation_operation_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Retrieve the current capacity of a key derivation operation."]
    #[doc = ""]
    #[doc = " The capacity of a key derivation is the maximum number of bytes that it can"]
    #[doc = " return. When you get *N* bytes of output from a key derivation operation,"]
    #[doc = " this reduces its capacity by *N*."]
    #[doc = ""]
    #[doc = " \\param[in] operation     The operation to query."]
    #[doc = " \\param[out] capacity     On success, the capacity of the operation."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active)."]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_get_capacity(
        operation: *const psa_key_derivation_operation_t,
        capacity: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the maximum capacity of a key derivation operation."]
    #[doc = ""]
    #[doc = " The capacity of a key derivation operation is the maximum number of bytes"]
    #[doc = " that the key derivation operation can return from this point onwards."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The key derivation operation object to modify."]
    #[doc = " \\param capacity          The new capacity of the operation."]
    #[doc = "                          It must be less or equal to the operation's"]
    #[doc = "                          current capacity."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p capacity is larger than the operation's current capacity."]
    #[doc = "         In this case, the operation object remains valid and its capacity"]
    #[doc = "         remains unchanged."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active)."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_set_capacity(
        operation: *mut psa_key_derivation_operation_t,
        capacity: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide an input for key derivation or key agreement."]
    #[doc = ""]
    #[doc = " Which inputs are required and in what order depends on the algorithm."]
    #[doc = " Refer to the documentation of each key derivation or key agreement"]
    #[doc = " algorithm for information."]
    #[doc = ""]
    #[doc = " This function passes direct inputs, which is usually correct for"]
    #[doc = " non-secret inputs. To pass a secret input, which should be in a key"]
    #[doc = " object, call psa_key_derivation_input_key() instead of this function."]
    #[doc = " Refer to the documentation of individual step types"]
    #[doc = " (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)"]
    #[doc = " for more information."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation       The key derivation operation object to use."]
    #[doc = "                                It must have been set up with"]
    #[doc = "                                psa_key_derivation_setup() and must not"]
    #[doc = "                                have produced any output yet."]
    #[doc = " \\param step                    Which step the input data is for."]
    #[doc = " \\param[in] data                Input data to use."]
    #[doc = " \\param data_length             Size of the \\p data buffer in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c step is not compatible with the operation's algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c step does not allow direct inputs."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid for this input \\p step."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_input_bytes(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        data: *const u8,
        data_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide a numeric input for key derivation or key agreement."]
    #[doc = ""]
    #[doc = " Which inputs are required and in what order depends on the algorithm."]
    #[doc = " However, when an algorithm requires a particular order, numeric inputs"]
    #[doc = " usually come first as they tend to be configuration parameters."]
    #[doc = " Refer to the documentation of each key derivation or key agreement"]
    #[doc = " algorithm for information."]
    #[doc = ""]
    #[doc = " This function is used for inputs which are fixed-size non-negative"]
    #[doc = " integers."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation       The key derivation operation object to use."]
    #[doc = "                                It must have been set up with"]
    #[doc = "                                psa_key_derivation_setup() and must not"]
    #[doc = "                                have produced any output yet."]
    #[doc = " \\param step                    Which step the input data is for."]
    #[doc = " \\param[in] value               The value of the numeric input."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c step is not compatible with the operation's algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c step does not allow numeric inputs."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid for this input \\p step."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_input_integer(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        value: u64,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide an input for key derivation in the form of a key."]
    #[doc = ""]
    #[doc = " Which inputs are required and in what order depends on the algorithm."]
    #[doc = " Refer to the documentation of each key derivation or key agreement"]
    #[doc = " algorithm for information."]
    #[doc = ""]
    #[doc = " This function obtains input from a key object, which is usually correct for"]
    #[doc = " secret inputs or for non-secret personalization strings kept in the key"]
    #[doc = " store. To pass a non-secret parameter which is not in the key store,"]
    #[doc = " call psa_key_derivation_input_bytes() instead of this function."]
    #[doc = " Refer to the documentation of individual step types"]
    #[doc = " (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)"]
    #[doc = " for more information."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation       The key derivation operation object to use."]
    #[doc = "                                It must have been set up with"]
    #[doc = "                                psa_key_derivation_setup() and must not"]
    #[doc = "                                have produced any output yet."]
    #[doc = " \\param step                    Which step the input data is for."]
    #[doc = " \\param key                     Identifier of the key. It must have an"]
    #[doc = "                                appropriate type for step and must allow the"]
    #[doc = "                                usage #PSA_KEY_USAGE_DERIVE or"]
    #[doc = "                                #PSA_KEY_USAGE_VERIFY_DERIVATION (see note)"]
    #[doc = "                                and the algorithm used by the operation."]
    #[doc = ""]
    #[doc = " \\note Once all inputs steps are completed, the operations will allow:"]
    #[doc = " - psa_key_derivation_output_bytes() if each input was either a direct input"]
    #[doc = "   or  a key with #PSA_KEY_USAGE_DERIVE set;"]
    #[doc = " - psa_key_derivation_output_key() if the input for step"]
    #[doc = "   #PSA_KEY_DERIVATION_INPUT_SECRET or #PSA_KEY_DERIVATION_INPUT_PASSWORD"]
    #[doc = "   was from a key slot with #PSA_KEY_USAGE_DERIVE and each other input was"]
    #[doc = "   either a direct input or a key with #PSA_KEY_USAGE_DERIVE set;"]
    #[doc = " - psa_key_derivation_verify_bytes() if each input was either a direct input"]
    #[doc = "   or  a key with #PSA_KEY_USAGE_VERIFY_DERIVATION set;"]
    #[doc = " - psa_key_derivation_verify_key() under the same conditions as"]
    #[doc = "   psa_key_derivation_verify_bytes()."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key allows neither #PSA_KEY_USAGE_DERIVE nor"]
    #[doc = "         #PSA_KEY_USAGE_VERIFY_DERIVATION, or it doesn't allow this"]
    #[doc = "         algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c step is not compatible with the operation's algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c step does not allow key inputs of the given type"]
    #[doc = "         or does not allow key inputs at all."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid for this input \\p step."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_input_key(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        key: psa_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Perform a key agreement and use the shared secret as input to a key"]
    #[doc = " derivation."]
    #[doc = ""]
    #[doc = " A key agreement algorithm takes two inputs: a private key \\p private_key"]
    #[doc = " a public key \\p peer_key."]
    #[doc = " The result of this function is passed as input to a key derivation."]
    #[doc = " The output of this key derivation can be extracted by reading from the"]
    #[doc = " resulting operation to produce keys and other cryptographic material."]
    #[doc = ""]
    #[doc = " If this function returns an error status, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation       The key derivation operation object to use."]
    #[doc = "                                It must have been set up with"]
    #[doc = "                                psa_key_derivation_setup() with a"]
    #[doc = "                                key agreement and derivation algorithm"]
    #[doc = "                                \\c alg (\\c PSA_ALG_XXX value such that"]
    #[doc = "                                #PSA_ALG_IS_KEY_AGREEMENT(\\c alg) is true"]
    #[doc = "                                and #PSA_ALG_IS_RAW_KEY_AGREEMENT(\\c alg)"]
    #[doc = "                                is false)."]
    #[doc = "                                The operation must be ready for an"]
    #[doc = "                                input of the type given by \\p step."]
    #[doc = " \\param step                    Which step the input data is for."]
    #[doc = " \\param private_key             Identifier of the private key to use. It must"]
    #[doc = "                                allow the usage #PSA_KEY_USAGE_DERIVE."]
    #[doc = " \\param[in] peer_key      Public key of the peer. The peer key must be in the"]
    #[doc = "                          same format that psa_import_key() accepts for the"]
    #[doc = "                          public key type corresponding to the type of"]
    #[doc = "                          private_key. That is, this function performs the"]
    #[doc = "                          equivalent of"]
    #[doc = "                          #psa_import_key(...,"]
    #[doc = "                          `peer_key`, `peer_key_length`) where"]
    #[doc = "                          with key attributes indicating the public key"]
    #[doc = "                          type corresponding to the type of `private_key`."]
    #[doc = "                          For example, for EC keys, this means that peer_key"]
    #[doc = "                          is interpreted as a point on the curve that the"]
    #[doc = "                          private key is on. The standard formats for public"]
    #[doc = "                          keys are documented in the documentation of"]
    #[doc = "                          psa_export_public_key()."]
    #[doc = " \\param peer_key_length         Size of \\p peer_key in bytes."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid for this key agreement \\p step."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c private_key is not compatible with \\c alg,"]
    #[doc = "         or \\p peer_key is not valid for \\c alg or not compatible with"]
    #[doc = "         \\c private_key."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\c alg is not supported or is not a key derivation algorithm."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\c step does not allow an input resulting from a key agreement."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_key_agreement(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        private_key: psa_key_id_t,
        peer_key: *const u8,
        peer_key_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Read some data from a key derivation operation."]
    #[doc = ""]
    #[doc = " This function calculates output bytes from a key derivation algorithm and"]
    #[doc = " return those bytes."]
    #[doc = " If you view the key derivation's output as a stream of bytes, this"]
    #[doc = " function destructively reads the requested number of bytes from the"]
    #[doc = " stream."]
    #[doc = " The operation's capacity decreases by the number of bytes read."]
    #[doc = ""]
    #[doc = " If this function returns an error status other than"]
    #[doc = " #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The key derivation operation object to read from."]
    #[doc = " \\param[out] output       Buffer where the output will be written."]
    #[doc = " \\param output_length     Number of bytes to output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         One of the inputs was a key whose policy didn't allow"]
    #[doc = "         #PSA_KEY_USAGE_DERIVE."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_DATA"]
    #[doc = "                          The operation's capacity was less than"]
    #[doc = "                          \\p output_length bytes. Note that in this case,"]
    #[doc = "                          no output is written to the output buffer."]
    #[doc = "                          The operation's capacity is set to 0, thus"]
    #[doc = "                          subsequent calls to this function will not"]
    #[doc = "                          succeed, even with a smaller output buffer."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active and completed"]
    #[doc = "         all required input steps)."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_output_bytes(
        operation: *mut psa_key_derivation_operation_t,
        output: *mut u8,
        output_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Derive a key from an ongoing key derivation operation."]
    #[doc = ""]
    #[doc = " This function calculates output bytes from a key derivation algorithm"]
    #[doc = " and uses those bytes to generate a key deterministically."]
    #[doc = " The key's location, usage policy, type and size are taken from"]
    #[doc = " \\p attributes."]
    #[doc = ""]
    #[doc = " If you view the key derivation's output as a stream of bytes, this"]
    #[doc = " function destructively reads as many bytes as required from the"]
    #[doc = " stream."]
    #[doc = " The operation's capacity decreases by the number of bytes read."]
    #[doc = ""]
    #[doc = " If this function returns an error status other than"]
    #[doc = " #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error"]
    #[doc = " state and must be aborted by calling psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " How much output is produced and consumed from the operation, and how"]
    #[doc = " the key is derived, depends on the key type and on the key size"]
    #[doc = " (denoted \\c bits below):"]
    #[doc = ""]
    #[doc = " - For key types for which the key is an arbitrary sequence of bytes"]
    #[doc = "   of a given size, this function is functionally equivalent to"]
    #[doc = "   calling #psa_key_derivation_output_bytes"]
    #[doc = "   and passing the resulting output to #psa_import_key."]
    #[doc = "   However, this function has a security benefit:"]
    #[doc = "   if the implementation provides an isolation boundary then"]
    #[doc = "   the key material is not exposed outside the isolation boundary."]
    #[doc = "   As a consequence, for these key types, this function always consumes"]
    #[doc = "   exactly (\\c bits / 8) bytes from the operation."]
    #[doc = "   The following key types defined in this specification follow this scheme:"]
    #[doc = ""]
    #[doc = "     - #PSA_KEY_TYPE_AES;"]
    #[doc = "     - #PSA_KEY_TYPE_CAMELLIA;"]
    #[doc = "     - #PSA_KEY_TYPE_DERIVE;"]
    #[doc = "     - #PSA_KEY_TYPE_HMAC;"]
    #[doc = "     - #PSA_KEY_TYPE_PASSWORD_HASH."]
    #[doc = ""]
    #[doc = " - For ECC keys on a Montgomery elliptic curve"]
    #[doc = "   (#PSA_KEY_TYPE_ECC_KEY_PAIR(\\c curve) where \\c curve designates a"]
    #[doc = "   Montgomery curve), this function always draws a byte string whose"]
    #[doc = "   length is determined by the curve, and sets the mandatory bits"]
    #[doc = "   accordingly. That is:"]
    #[doc = ""]
    #[doc = "     - Curve25519 (#PSA_ECC_FAMILY_MONTGOMERY, 255 bits): draw a 32-byte"]
    #[doc = "       string and process it as specified in RFC 7748 &sect;5."]
    #[doc = "     - Curve448 (#PSA_ECC_FAMILY_MONTGOMERY, 448 bits): draw a 56-byte"]
    #[doc = "       string and process it as specified in RFC 7748 &sect;5."]
    #[doc = ""]
    #[doc = " - For key types for which the key is represented by a single sequence of"]
    #[doc = "   \\c bits bits with constraints as to which bit sequences are acceptable,"]
    #[doc = "   this function draws a byte string of length (\\c bits / 8) bytes rounded"]
    #[doc = "   up to the nearest whole number of bytes. If the resulting byte string"]
    #[doc = "   is acceptable, it becomes the key, otherwise the drawn bytes are discarded."]
    #[doc = "   This process is repeated until an acceptable byte string is drawn."]
    #[doc = "   The byte string drawn from the operation is interpreted as specified"]
    #[doc = "   for the output produced by psa_export_key()."]
    #[doc = "   The following key types defined in this specification follow this scheme:"]
    #[doc = ""]
    #[doc = "     - #PSA_KEY_TYPE_DES."]
    #[doc = "       Force-set the parity bits, but discard forbidden weak keys."]
    #[doc = "       For 2-key and 3-key triple-DES, the three keys are generated"]
    #[doc = "       successively (for example, for 3-key triple-DES,"]
    #[doc = "       if the first 8 bytes specify a weak key and the next 8 bytes do not,"]
    #[doc = "       discard the first 8 bytes, use the next 8 bytes as the first key,"]
    #[doc = "       and continue reading output from the operation to derive the other"]
    #[doc = "       two keys)."]
    #[doc = "     - Finite-field Diffie-Hellman keys (#PSA_KEY_TYPE_DH_KEY_PAIR(\\c group)"]
    #[doc = "       where \\c group designates any Diffie-Hellman group) and"]
    #[doc = "       ECC keys on a Weierstrass elliptic curve"]
    #[doc = "       (#PSA_KEY_TYPE_ECC_KEY_PAIR(\\c curve) where \\c curve designates a"]
    #[doc = "       Weierstrass curve)."]
    #[doc = "       For these key types, interpret the byte string as integer"]
    #[doc = "       in big-endian order. Discard it if it is not in the range"]
    #[doc = "       [0, *N* - 2] where *N* is the boundary of the private key domain"]
    #[doc = "       (the prime *p* for Diffie-Hellman, the subprime *q* for DSA,"]
    #[doc = "       or the order of the curve's base point for ECC)."]
    #[doc = "       Add 1 to the resulting integer and use this as the private key *x*."]
    #[doc = "       This method allows compliance to NIST standards, specifically"]
    #[doc = "       the methods titled \"key-pair generation by testing candidates\""]
    #[doc = "       in NIST SP 800-56A &sect;5.6.1.1.4 for Diffie-Hellman,"]
    #[doc = "       in FIPS 186-4 &sect;B.1.2 for DSA, and"]
    #[doc = "       in NIST SP 800-56A &sect;5.6.1.2.2 or"]
    #[doc = "       FIPS 186-4 &sect;B.4.2 for elliptic curve keys."]
    #[doc = ""]
    #[doc = " - For other key types, including #PSA_KEY_TYPE_RSA_KEY_PAIR,"]
    #[doc = "   the way in which the operation output is consumed is"]
    #[doc = "   implementation-defined."]
    #[doc = ""]
    #[doc = " In all cases, the data that is read is discarded from the operation."]
    #[doc = " The operation's capacity is decreased by the number of bytes read."]
    #[doc = ""]
    #[doc = " For algorithms that take an input step #PSA_KEY_DERIVATION_INPUT_SECRET,"]
    #[doc = " the input to that step must be provided with psa_key_derivation_input_key()."]
    #[doc = " Future versions of this specification may include additional restrictions"]
    #[doc = " on the derived key based on the attributes and strength of the secret key."]
    #[doc = ""]
    #[doc = " \\param[in] attributes    The attributes for the new key."]
    #[doc = "                          If the key type to be created is"]
    #[doc = "                          #PSA_KEY_TYPE_PASSWORD_HASH then the algorithm in"]
    #[doc = "                          the policy must be the same as in the current"]
    #[doc = "                          operation."]
    #[doc = " \\param[in,out] operation The key derivation operation object to read from."]
    #[doc = " \\param[out] key          On success, an identifier for the newly created"]
    #[doc = "                          key. For persistent keys, this is the key"]
    #[doc = "                          identifier defined in \\p attributes."]
    #[doc = "                          \\c 0 on failure."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = "         If the key is persistent, the key material and the key's metadata"]
    #[doc = "         have been saved to persistent storage."]
    #[doc = " \\retval #PSA_ERROR_ALREADY_EXISTS"]
    #[doc = "         This is an attempt to create a persistent key, and there is"]
    #[doc = "         already a persistent key with the given identifier."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_DATA"]
    #[doc = "         There was not enough data to create the desired key."]
    #[doc = "         Note that in this case, no output is written to the output buffer."]
    #[doc = "         The operation's capacity is set to 0, thus subsequent calls to"]
    #[doc = "         this function will not succeed, even with a smaller output buffer."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         The key type or key size is not supported, either by the"]
    #[doc = "         implementation in general or in this particular location."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The provided key attributes are not valid for the operation."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The #PSA_KEY_DERIVATION_INPUT_SECRET or"]
    #[doc = "         #PSA_KEY_DERIVATION_INPUT_PASSWORD input was not provided through a"]
    #[doc = "         key; or one of the inputs was a key whose policy didn't allow"]
    #[doc = "         #PSA_KEY_USAGE_DERIVE."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active and completed"]
    #[doc = "         all required input steps)."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_STORAGE"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_output_key(
        attributes: *const psa_key_attributes_t,
        operation: *mut psa_key_derivation_operation_t,
        key: *mut psa_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Compare output data from a key derivation operation to an expected value."]
    #[doc = ""]
    #[doc = " This function calculates output bytes from a key derivation algorithm and"]
    #[doc = " compares those bytes to an expected value in constant time."]
    #[doc = " If you view the key derivation's output as a stream of bytes, this"]
    #[doc = " function destructively reads the expected number of bytes from the"]
    #[doc = " stream before comparing them."]
    #[doc = " The operation's capacity decreases by the number of bytes read."]
    #[doc = ""]
    #[doc = " This is functionally equivalent to the following code:"]
    #[doc = " \\code"]
    #[doc = " psa_key_derivation_output_bytes(operation, tmp, output_length);"]
    #[doc = " if (memcmp(output, tmp, output_length) != 0)"]
    #[doc = "     return PSA_ERROR_INVALID_SIGNATURE;"]
    #[doc = " \\endcode"]
    #[doc = " except (1) it works even if the key's policy does not allow outputting the"]
    #[doc = " bytes, and (2) the comparison will be done in constant time."]
    #[doc = ""]
    #[doc = " If this function returns an error status other than"]
    #[doc = " #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,"]
    #[doc = " the operation enters an error state and must be aborted by calling"]
    #[doc = " psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The key derivation operation object to read from."]
    #[doc = " \\param[in] expected_output Buffer containing the expected derivation output."]
    #[doc = " \\param output_length     Length ot the expected output; this is also the"]
    #[doc = "                          number of bytes that will be read."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The output was read successfully, but it differs from the expected"]
    #[doc = "         output."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         One of the inputs was a key whose policy didn't allow"]
    #[doc = "         #PSA_KEY_USAGE_VERIFY_DERIVATION."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_DATA"]
    #[doc = "                          The operation's capacity was less than"]
    #[doc = "                          \\p output_length bytes. Note that in this case,"]
    #[doc = "                          the operation's capacity is set to 0, thus"]
    #[doc = "                          subsequent calls to this function will not"]
    #[doc = "                          succeed, even with a smaller expected output."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active and completed"]
    #[doc = "         all required input steps)."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_verify_bytes(
        operation: *mut psa_key_derivation_operation_t,
        expected_output: *const u8,
        output_length: size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Compare output data from a key derivation operation to an expected value"]
    #[doc = " stored in a key object."]
    #[doc = ""]
    #[doc = " This function calculates output bytes from a key derivation algorithm and"]
    #[doc = " compares those bytes to an expected value, provided as key of type"]
    #[doc = " #PSA_KEY_TYPE_PASSWORD_HASH."]
    #[doc = " If you view the key derivation's output as a stream of bytes, this"]
    #[doc = " function destructively reads the number of bytes corresponding the the"]
    #[doc = " length of the expected value from the stream before comparing them."]
    #[doc = " The operation's capacity decreases by the number of bytes read."]
    #[doc = ""]
    #[doc = " This is functionally equivalent to exporting the key and calling"]
    #[doc = " psa_key_derivation_verify_bytes() on the result, except that it"]
    #[doc = " works even if the key cannot be exported."]
    #[doc = ""]
    #[doc = " If this function returns an error status other than"]
    #[doc = " #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,"]
    #[doc = " the operation enters an error state and must be aborted by calling"]
    #[doc = " psa_key_derivation_abort()."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation The key derivation operation object to read from."]
    #[doc = " \\param[in] expected      A key of type #PSA_KEY_TYPE_PASSWORD_HASH"]
    #[doc = "                          containing the expected output. Its policy must"]
    #[doc = "                          include the #PSA_KEY_USAGE_VERIFY_DERIVATION flag"]
    #[doc = "                          and the permitted algorithm must match the"]
    #[doc = "                          operation. The value of this key was likely"]
    #[doc = "                          computed by a previous call to"]
    #[doc = "                          psa_key_derivation_output_key()."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_INVALID_SIGNATURE"]
    #[doc = "         The output was read successfully, but if differs from the expected"]
    #[doc = "         output."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = "         The key passed as the expected value does not exist."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         The key passed as the expected value has an invalid type."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The key passed as the expected value does not allow this usage or"]
    #[doc = "         this algorithm; or one of the inputs was a key whose policy didn't"]
    #[doc = "         allow #PSA_KEY_USAGE_VERIFY_DERIVATION."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_DATA"]
    #[doc = "                          The operation's capacity was less than"]
    #[doc = "                          the length of the expected value. In this case,"]
    #[doc = "                          the operation's capacity is set to 0, thus"]
    #[doc = "                          subsequent calls to this function will not"]
    #[doc = "                          succeed, even with a smaller expected output."]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The operation state is not valid (it must be active and completed"]
    #[doc = "         all required input steps)."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_verify_key(
        operation: *mut psa_key_derivation_operation_t,
        expected: psa_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a key derivation operation."]
    #[doc = ""]
    #[doc = " Aborting an operation frees all associated resources except for the \\c"]
    #[doc = " operation structure itself. Once aborted, the operation object can be reused"]
    #[doc = " for another operation by calling psa_key_derivation_setup() again."]
    #[doc = ""]
    #[doc = " This function may be called at any time after the operation"]
    #[doc = " object has been initialized as described in #psa_key_derivation_operation_t."]
    #[doc = ""]
    #[doc = " In particular, it is valid to call psa_key_derivation_abort() twice, or to"]
    #[doc = " call psa_key_derivation_abort() on an operation that has not been set up."]
    #[doc = ""]
    #[doc = " \\param[in,out] operation    The operation to abort."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_key_derivation_abort(operation: *mut psa_key_derivation_operation_t)
        -> psa_status_t;
}
extern "C" {
    #[doc = " Perform a key agreement and return the raw shared secret."]
    #[doc = ""]
    #[doc = " \\warning The raw result of a key agreement algorithm such as finite-field"]
    #[doc = " Diffie-Hellman or elliptic curve Diffie-Hellman has biases and should"]
    #[doc = " not be used directly as key material. It should instead be passed as"]
    #[doc = " input to a key derivation algorithm. To chain a key agreement with"]
    #[doc = " a key derivation, use psa_key_derivation_key_agreement() and other"]
    #[doc = " functions from the key derivation interface."]
    #[doc = ""]
    #[doc = " \\param alg                     The key agreement algorithm to compute"]
    #[doc = "                                (\\c PSA_ALG_XXX value such that"]
    #[doc = "                                #PSA_ALG_IS_RAW_KEY_AGREEMENT(\\p alg)"]
    #[doc = "                                is true)."]
    #[doc = " \\param private_key             Identifier of the private key to use. It must"]
    #[doc = "                                allow the usage #PSA_KEY_USAGE_DERIVE."]
    #[doc = " \\param[in] peer_key            Public key of the peer. It must be"]
    #[doc = "                                in the same format that psa_import_key()"]
    #[doc = "                                accepts. The standard formats for public"]
    #[doc = "                                keys are documented in the documentation"]
    #[doc = "                                of psa_export_public_key()."]
    #[doc = " \\param peer_key_length         Size of \\p peer_key in bytes."]
    #[doc = " \\param[out] output             Buffer where the decrypted message is to"]
    #[doc = "                                be written."]
    #[doc = " \\param output_size             Size of the \\c output buffer in bytes."]
    #[doc = " \\param[out] output_length      On success, the number of bytes"]
    #[doc = "                                that make up the returned output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p alg is not a key agreement algorithm"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p private_key is not compatible with \\p alg,"]
    #[doc = "         or \\p peer_key is not valid for \\p alg or not compatible with"]
    #[doc = "         \\p private_key."]
    #[doc = " \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    #[doc = "         \\p output_size is too small"]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = "         \\p alg is not a supported key agreement algorithm."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_raw_key_agreement(
        alg: psa_algorithm_t,
        private_key: psa_key_id_t,
        peer_key: *const u8,
        peer_key_length: size_t,
        output: *mut u8,
        output_size: size_t,
        output_length: *mut size_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Generate random bytes."]
    #[doc = ""]
    #[doc = " \\warning This function **can** fail! Callers MUST check the return status"]
    #[doc = "          and MUST NOT use the content of the output buffer if the return"]
    #[doc = "          status is not #PSA_SUCCESS."]
    #[doc = ""]
    #[doc = " \\note    To generate a key, use psa_generate_key() instead."]
    #[doc = ""]
    #[doc = " \\param[out] output       Output buffer for the generated data."]
    #[doc = " \\param output_size       Number of bytes to generate and output."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_generate_random(output: *mut u8, output_size: size_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Generate a key or key pair."]
    #[doc = ""]
    #[doc = " The key is generated randomly."]
    #[doc = " Its location, usage policy, type and size are taken from \\p attributes."]
    #[doc = ""]
    #[doc = " Implementations must reject an attempt to generate a key of size 0."]
    #[doc = ""]
    #[doc = " The following type-specific considerations apply:"]
    #[doc = " - For RSA keys (#PSA_KEY_TYPE_RSA_KEY_PAIR),"]
    #[doc = "   the public exponent is 65537."]
    #[doc = "   The modulus is a product of two probabilistic primes"]
    #[doc = "   between 2^{n-1} and 2^n where n is the bit size specified in the"]
    #[doc = "   attributes."]
    #[doc = ""]
    #[doc = " \\param[in] attributes    The attributes for the new key."]
    #[doc = " \\param[out] key          On success, an identifier for the newly created"]
    #[doc = "                          key. For persistent keys, this is the key"]
    #[doc = "                          identifier defined in \\p attributes."]
    #[doc = "                          \\c 0 on failure."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success."]
    #[doc = "         If the key is persistent, the key material and the key's metadata"]
    #[doc = "         have been saved to persistent storage."]
    #[doc = " \\retval #PSA_ERROR_ALREADY_EXISTS"]
    #[doc = "         This is an attempt to create a persistent key, and there is"]
    #[doc = "         already a persistent key with the given identifier."]
    #[doc = " \\retval #PSA_ERROR_NOT_SUPPORTED"]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY"]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_HARDWARE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_STORAGE"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_generate_key(
        attributes: *const psa_key_attributes_t,
        key: *mut psa_key_id_t,
    ) -> psa_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_client_key_attributes_s {
    pub type_: u16,
    pub bits: u16,
    pub lifetime: u32,
    pub id: psa_key_id_t,
    pub usage: u32,
    pub alg: u32,
    pub alg2: u32,
    pub flags: u16,
    pub domain_parameters: *mut ::std::os::raw::c_void,
    pub domain_parameters_size: u32,
}
#[test]
fn bindgen_test_layout_psa_client_key_attributes_s() {
    assert_eq!(
        ::std::mem::size_of::<psa_client_key_attributes_s>(),
        48usize,
        concat!("Size of: ", stringify!(psa_client_key_attributes_s))
    );
    assert_eq!(
        ::std::mem::align_of::<psa_client_key_attributes_s>(),
        8usize,
        concat!("Alignment of ", stringify!(psa_client_key_attributes_s))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<psa_client_key_attributes_s>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_client_key_attributes_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<psa_client_key_attributes_s>())).bits as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_client_key_attributes_s),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<psa_client_key_attributes_s>())).lifetime as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_client_key_attributes_s),
            "::",
            stringify!(lifetime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<psa_client_key_attributes_s>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_client_key_attributes_s),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<psa_client_key_attributes_s>())).usage as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_client_key_attributes_s),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<psa_client_key_attributes_s>())).alg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_client_key_attributes_s),
            "::",
            stringify!(alg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<psa_client_key_attributes_s>())).alg2 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_client_key_attributes_s),
            "::",
            stringify!(alg2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<psa_client_key_attributes_s>())).flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_client_key_attributes_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<psa_client_key_attributes_s>())).domain_parameters as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_client_key_attributes_s),
            "::",
            stringify!(domain_parameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<psa_client_key_attributes_s>())).domain_parameters_size
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_client_key_attributes_s),
            "::",
            stringify!(domain_parameters_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_hash_operation_s {
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_psa_hash_operation_s() {
    assert_eq!(
        ::std::mem::size_of::<psa_hash_operation_s>(),
        4usize,
        concat!("Size of: ", stringify!(psa_hash_operation_s))
    );
    assert_eq!(
        ::std::mem::align_of::<psa_hash_operation_s>(),
        4usize,
        concat!("Alignment of ", stringify!(psa_hash_operation_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<psa_hash_operation_s>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_hash_operation_s),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_mac_operation_s {
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_psa_mac_operation_s() {
    assert_eq!(
        ::std::mem::size_of::<psa_mac_operation_s>(),
        4usize,
        concat!("Size of: ", stringify!(psa_mac_operation_s))
    );
    assert_eq!(
        ::std::mem::align_of::<psa_mac_operation_s>(),
        4usize,
        concat!("Alignment of ", stringify!(psa_mac_operation_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<psa_mac_operation_s>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_mac_operation_s),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_cipher_operation_s {
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_psa_cipher_operation_s() {
    assert_eq!(
        ::std::mem::size_of::<psa_cipher_operation_s>(),
        4usize,
        concat!("Size of: ", stringify!(psa_cipher_operation_s))
    );
    assert_eq!(
        ::std::mem::align_of::<psa_cipher_operation_s>(),
        4usize,
        concat!("Alignment of ", stringify!(psa_cipher_operation_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<psa_cipher_operation_s>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_cipher_operation_s),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_aead_operation_s {
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_psa_aead_operation_s() {
    assert_eq!(
        ::std::mem::size_of::<psa_aead_operation_s>(),
        4usize,
        concat!("Size of: ", stringify!(psa_aead_operation_s))
    );
    assert_eq!(
        ::std::mem::align_of::<psa_aead_operation_s>(),
        4usize,
        concat!("Alignment of ", stringify!(psa_aead_operation_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<psa_aead_operation_s>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_aead_operation_s),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_key_derivation_s {
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_psa_key_derivation_s() {
    assert_eq!(
        ::std::mem::size_of::<psa_key_derivation_s>(),
        4usize,
        concat!("Size of: ", stringify!(psa_key_derivation_s))
    );
    assert_eq!(
        ::std::mem::align_of::<psa_key_derivation_s>(),
        4usize,
        concat!("Alignment of ", stringify!(psa_key_derivation_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<psa_key_derivation_s>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(psa_key_derivation_s),
            "::",
            stringify!(handle)
        )
    );
}
pub type psa_key_bits_t = u16;
pub type psa_key_handle_t = psa_key_id_t;
extern "C" {
    #[doc = " Open a handle to an existing persistent key."]
    #[doc = ""]
    #[doc = " Open a handle to a persistent key. A key is persistent if it was created"]
    #[doc = " with a lifetime other than #PSA_KEY_LIFETIME_VOLATILE. A persistent key"]
    #[doc = " always has a nonzero key identifier, set with psa_set_key_id() when"]
    #[doc = " creating the key. Implementations may provide additional pre-provisioned"]
    #[doc = " keys that can be opened with psa_open_key(). Such keys have an application"]
    #[doc = " key identifier in the vendor range, as documented in the description of"]
    #[doc = " #psa_key_id_t."]
    #[doc = ""]
    #[doc = " The application must eventually close the handle with psa_close_key() or"]
    #[doc = " psa_destroy_key() to release associated resources. If the application dies"]
    #[doc = " without calling one of these functions, the implementation should perform"]
    #[doc = " the equivalent of a call to psa_close_key()."]
    #[doc = ""]
    #[doc = " Some implementations permit an application to open the same key multiple"]
    #[doc = " times. If this is successful, each call to psa_open_key() will return a"]
    #[doc = " different key handle."]
    #[doc = ""]
    #[doc = " \\note This API is not part of the PSA Cryptography API Release 1.0.0"]
    #[doc = " specification. It was defined in the 1.0 Beta 3 version of the"]
    #[doc = " specification but was removed in the 1.0.0 released version. This API is"]
    #[doc = " kept for the time being to not break applications relying on it. It is not"]
    #[doc = " deprecated yet but will be in the near future."]
    #[doc = ""]
    #[doc = " \\note Applications that rely on opening a key multiple times will not be"]
    #[doc = " portable to implementations that only permit a single key handle to be"]
    #[doc = " opened. See also :ref:\\`key-handles\\`."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param id           The persistent identifier of the key."]
    #[doc = " \\param[out] key     On success, a handle to the key."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         Success. The application can now use the value of `*handle`"]
    #[doc = "         to access the key."]
    #[doc = " \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    #[doc = "         The implementation does not have sufficient resources to open the"]
    #[doc = "         key. This can be due to reaching an implementation limit on the"]
    #[doc = "         number of open keys, the number of open key handles, or available"]
    #[doc = "         memory."]
    #[doc = " \\retval #PSA_ERROR_DOES_NOT_EXIST"]
    #[doc = "         There is no persistent key with key identifier \\p id."]
    #[doc = " \\retval #PSA_ERROR_INVALID_ARGUMENT"]
    #[doc = "         \\p id is not a valid persistent key identifier."]
    #[doc = " \\retval #PSA_ERROR_NOT_PERMITTED"]
    #[doc = "         The specified key exists, but the application does not have the"]
    #[doc = "         permission to access it. Note that this specification does not"]
    #[doc = "         define any way to create such a key, but it may be possible"]
    #[doc = "         through implementation-specific means."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_STORAGE_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_DATA_INVALID"]
    #[doc = " \\retval #PSA_ERROR_DATA_CORRUPT"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_open_key(id: psa_key_id_t, key: *mut psa_key_id_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Close a key handle."]
    #[doc = ""]
    #[doc = " If the handle designates a volatile key, this will destroy the key material"]
    #[doc = " and free all associated resources, just like psa_destroy_key()."]
    #[doc = ""]
    #[doc = " If this is the last open handle to a persistent key, then closing the handle"]
    #[doc = " will free all resources associated with the key in volatile memory. The key"]
    #[doc = " data in persistent storage is not affected and can be opened again later"]
    #[doc = " with a call to psa_open_key()."]
    #[doc = ""]
    #[doc = " Closing the key handle makes the handle invalid, and the key handle"]
    #[doc = " must not be used again by the application."]
    #[doc = ""]
    #[doc = " \\note This API is not part of the PSA Cryptography API Release 1.0.0"]
    #[doc = " specification. It was defined in the 1.0 Beta 3 version of the"]
    #[doc = " specification but was removed in the 1.0.0 released version. This API is"]
    #[doc = " kept for the time being to not break applications relying on it. It is not"]
    #[doc = " deprecated yet but will be in the near future."]
    #[doc = ""]
    #[doc = " \\note If the key handle was used to set up an active"]
    #[doc = " :ref:\\`multipart operation <multipart-operations>\\`, then closing the"]
    #[doc = " key handle can cause the multipart operation to fail. Applications should"]
    #[doc = " maintain the key handle until after the multipart operation has finished."]
    #[doc = ""]
    #[doc = " \\param key           The key to close."]
    #[doc = "                      If this is \\c 0, do nothing and return \\c PSA_SUCCESS."]
    #[doc = ""]
    #[doc = " \\retval #PSA_SUCCESS"]
    #[doc = "         \\p handle was a valid handle or \\c 0. It is now closed."]
    #[doc = " \\retval #PSA_ERROR_INVALID_HANDLE"]
    #[doc = "         \\p handle is not a valid handle nor \\c 0."]
    #[doc = " \\retval #PSA_ERROR_COMMUNICATION_FAILURE"]
    #[doc = " \\retval #PSA_ERROR_CORRUPTION_DETECTED"]
    #[doc = " \\retval #PSA_ERROR_BAD_STATE"]
    #[doc = "         The library has not been previously initialized by psa_crypto_init()."]
    #[doc = "         It is implementation-dependent whether a failure to initialize"]
    #[doc = "         results in this error code."]
    pub fn psa_close_key(key: psa_key_id_t) -> psa_status_t;
}
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cJSON {
    pub next: *mut cJSON,
    pub prev: *mut cJSON,
    pub child: *mut cJSON,
    pub type_: ::std::os::raw::c_int,
    pub valuestring: *mut ::std::os::raw::c_char,
    pub valueint: ::std::os::raw::c_int,
    pub valuedouble: f64,
    pub string: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cJSON() {
    assert_eq!(
        ::std::mem::size_of::<cJSON>(),
        64usize,
        concat!("Size of: ", stringify!(cJSON))
    );
    assert_eq!(
        ::std::mem::align_of::<cJSON>(),
        8usize,
        concat!("Alignment of ", stringify!(cJSON))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cJSON>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cJSON>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cJSON>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cJSON>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cJSON>())).valuestring as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(valuestring)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cJSON>())).valueint as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(valueint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cJSON>())).valuedouble as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(valuedouble)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cJSON>())).string as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(string)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cJSON_Hooks {
    pub malloc_fn:
        ::std::option::Option<unsafe extern "C" fn(sz: size_t) -> *mut ::std::os::raw::c_void>,
    pub free_fn: ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_cJSON_Hooks() {
    assert_eq!(
        ::std::mem::size_of::<cJSON_Hooks>(),
        16usize,
        concat!("Size of: ", stringify!(cJSON_Hooks))
    );
    assert_eq!(
        ::std::mem::align_of::<cJSON_Hooks>(),
        8usize,
        concat!("Alignment of ", stringify!(cJSON_Hooks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cJSON_Hooks>())).malloc_fn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON_Hooks),
            "::",
            stringify!(malloc_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cJSON_Hooks>())).free_fn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON_Hooks),
            "::",
            stringify!(free_fn)
        )
    );
}
pub type cJSON_bool = ::std::os::raw::c_int;
extern "C" {
    pub fn cJSON_Version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_InitHooks(hooks: *mut cJSON_Hooks);
}
extern "C" {
    pub fn cJSON_Parse(value: *const ::std::os::raw::c_char) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_ParseWithLength(
        value: *const ::std::os::raw::c_char,
        buffer_length: size_t,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_ParseWithOpts(
        value: *const ::std::os::raw::c_char,
        return_parse_end: *mut *const ::std::os::raw::c_char,
        require_null_terminated: cJSON_bool,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_ParseWithLengthOpts(
        value: *const ::std::os::raw::c_char,
        buffer_length: size_t,
        return_parse_end: *mut *const ::std::os::raw::c_char,
        require_null_terminated: cJSON_bool,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_Print(item: *const cJSON) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_PrintUnformatted(item: *const cJSON) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_PrintBuffered(
        item: *const cJSON,
        prebuffer: ::std::os::raw::c_int,
        fmt: cJSON_bool,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_PrintPreallocated(
        item: *mut cJSON,
        buffer: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        format: cJSON_bool,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_Delete(item: *mut cJSON);
}
extern "C" {
    pub fn cJSON_GetArraySize(array: *const cJSON) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cJSON_GetArrayItem(array: *const cJSON, index: ::std::os::raw::c_int) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_GetObjectItem(
        object: *const cJSON,
        string: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_GetObjectItemCaseSensitive(
        object: *const cJSON,
        string: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_HasObjectItem(
        object: *const cJSON,
        string: *const ::std::os::raw::c_char,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_GetErrorPtr() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_GetStringValue(item: *const cJSON) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_GetNumberValue(item: *const cJSON) -> f64;
}
extern "C" {
    pub fn cJSON_IsInvalid(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsFalse(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsTrue(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsBool(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsNull(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsNumber(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsString(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsArray(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsObject(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsRaw(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_CreateNull() -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateTrue() -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateFalse() -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateBool(boolean: cJSON_bool) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateNumber(num: f64) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateString(string: *const ::std::os::raw::c_char) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateRaw(raw: *const ::std::os::raw::c_char) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateArray() -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateObject() -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateStringReference(string: *const ::std::os::raw::c_char) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateObjectReference(child: *const cJSON) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateArrayReference(child: *const cJSON) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateIntArray(
        numbers: *const ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateFloatArray(numbers: *const f32, count: ::std::os::raw::c_int) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateDoubleArray(numbers: *const f64, count: ::std::os::raw::c_int)
        -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateStringArray(
        strings: *const *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddItemToArray(array: *mut cJSON, item: *mut cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_AddItemToObject(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
        item: *mut cJSON,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_AddItemToObjectCS(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
        item: *mut cJSON,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_AddItemReferenceToArray(array: *mut cJSON, item: *mut cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_AddItemReferenceToObject(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
        item: *mut cJSON,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_DetachItemViaPointer(parent: *mut cJSON, item: *mut cJSON) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_DetachItemFromArray(array: *mut cJSON, which: ::std::os::raw::c_int)
        -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_DeleteItemFromArray(array: *mut cJSON, which: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cJSON_DetachItemFromObject(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_DetachItemFromObjectCaseSensitive(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_DeleteItemFromObject(object: *mut cJSON, string: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn cJSON_DeleteItemFromObjectCaseSensitive(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn cJSON_InsertItemInArray(
        array: *mut cJSON,
        which: ::std::os::raw::c_int,
        newitem: *mut cJSON,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_ReplaceItemViaPointer(
        parent: *mut cJSON,
        item: *mut cJSON,
        replacement: *mut cJSON,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_ReplaceItemInArray(
        array: *mut cJSON,
        which: ::std::os::raw::c_int,
        newitem: *mut cJSON,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_ReplaceItemInObject(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
        newitem: *mut cJSON,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_ReplaceItemInObjectCaseSensitive(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
        newitem: *mut cJSON,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_Duplicate(item: *const cJSON, recurse: cJSON_bool) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_Compare(
        a: *const cJSON,
        b: *const cJSON,
        case_sensitive: cJSON_bool,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_Minify(json: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn cJSON_AddNullToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddTrueToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddFalseToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddBoolToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
        boolean: cJSON_bool,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddNumberToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
        number: f64,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddStringToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
        string: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddRawToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
        raw: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddObjectToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddArrayToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_SetNumberHelper(object: *mut cJSON, number: f64) -> f64;
}
extern "C" {
    pub fn cJSON_SetValuestring(
        object: *mut cJSON,
        valuestring: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cJSON_free(object: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn base64_encode(
        indata: *const ::std::os::raw::c_char,
        inlen: size_t,
        outdata: *mut ::std::os::raw::c_char,
        outlen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn base64_decode(
        indata: *const ::std::os::raw::c_char,
        inlen: size_t,
        outdata: *mut ::std::os::raw::c_char,
        outlen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn base64url_encode(
        indata: *const ::std::os::raw::c_char,
        inlen: size_t,
        outdata: *mut ::std::os::raw::c_char,
        outlen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn base64url_decode(
        indata: *const ::std::os::raw::c_char,
        inlen: size_t,
        outdata: *mut ::std::os::raw::c_char,
        outlen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn base64url_malloc(len: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn base64_encode_automatic(
        buf: *const ::std::os::raw::c_char,
        buf_len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn base64_decode_automatic(
        inbuf: *const ::std::os::raw::c_char,
        inbuf_len: size_t,
        out_len: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn keccak256_getHash(msg: *const u8, len: size_t, hashResult: *mut u8);
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type pb_type_t = uint_least8_t;
pub type pb_size_t = uint_least16_t;
pub type pb_ssize_t = int_least16_t;
pub type pb_byte_t = uint_least8_t;
pub type pb_istream_t = pb_istream_s;
pub type pb_ostream_t = pb_ostream_s;
pub type pb_field_iter_t = pb_field_iter_s;
pub type pb_msgdesc_t = pb_msgdesc_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_msgdesc_s {
    pub field_info: *const u32,
    pub submsg_info: *const *const pb_msgdesc_t,
    pub default_value: *const pb_byte_t,
    pub field_callback: ::std::option::Option<
        unsafe extern "C" fn(
            istream: *mut pb_istream_t,
            ostream: *mut pb_ostream_t,
            field: *const pb_field_iter_t,
        ) -> bool,
    >,
    pub field_count: pb_size_t,
    pub required_field_count: pb_size_t,
    pub largest_tag: pb_size_t,
}
#[test]
fn bindgen_test_layout_pb_msgdesc_s() {
    assert_eq!(
        ::std::mem::size_of::<pb_msgdesc_s>(),
        40usize,
        concat!("Size of: ", stringify!(pb_msgdesc_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_msgdesc_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_msgdesc_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_msgdesc_s>())).field_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_msgdesc_s>())).submsg_info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(submsg_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_msgdesc_s>())).default_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_msgdesc_s>())).field_callback as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_msgdesc_s>())).field_count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pb_msgdesc_s>())).required_field_count as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(required_field_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_msgdesc_s>())).largest_tag as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(largest_tag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_field_iter_s {
    pub descriptor: *const pb_msgdesc_t,
    pub message: *mut ::std::os::raw::c_void,
    pub index: pb_size_t,
    pub field_info_index: pb_size_t,
    pub required_field_index: pb_size_t,
    pub submessage_index: pb_size_t,
    pub tag: pb_size_t,
    pub data_size: pb_size_t,
    pub array_size: pb_size_t,
    pub type_: pb_type_t,
    pub pField: *mut ::std::os::raw::c_void,
    pub pData: *mut ::std::os::raw::c_void,
    pub pSize: *mut ::std::os::raw::c_void,
    pub submsg_desc: *const pb_msgdesc_t,
}
#[test]
fn bindgen_test_layout_pb_field_iter_s() {
    assert_eq!(
        ::std::mem::size_of::<pb_field_iter_s>(),
        64usize,
        concat!("Size of: ", stringify!(pb_field_iter_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_field_iter_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_field_iter_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_field_iter_s>())).descriptor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(descriptor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_field_iter_s>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_field_iter_s>())).index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pb_field_iter_s>())).field_info_index as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(field_info_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pb_field_iter_s>())).required_field_index as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(required_field_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pb_field_iter_s>())).submessage_index as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(submessage_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_field_iter_s>())).tag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_field_iter_s>())).data_size as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_field_iter_s>())).array_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(array_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_field_iter_s>())).type_ as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_field_iter_s>())).pField as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_field_iter_s>())).pData as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_field_iter_s>())).pSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_field_iter_s>())).submsg_desc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(submsg_desc)
        )
    );
}
pub type pb_field_t = pb_field_iter_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_bytes_array_s {
    pub size: pb_size_t,
    pub bytes: [pb_byte_t; 1usize],
}
#[test]
fn bindgen_test_layout_pb_bytes_array_s() {
    assert_eq!(
        ::std::mem::size_of::<pb_bytes_array_s>(),
        4usize,
        concat!("Size of: ", stringify!(pb_bytes_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_bytes_array_s>(),
        2usize,
        concat!("Alignment of ", stringify!(pb_bytes_array_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_bytes_array_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_bytes_array_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_bytes_array_s>())).bytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_bytes_array_s),
            "::",
            stringify!(bytes)
        )
    );
}
pub type pb_bytes_array_t = pb_bytes_array_s;
pub type pb_callback_t = pb_callback_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pb_callback_s {
    pub funcs: pb_callback_s__bindgen_ty_1,
    pub arg: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pb_callback_s__bindgen_ty_1 {
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_istream_t,
            field: *const pb_field_t,
            arg: *mut *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    pub encode: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_ostream_t,
            field: *const pb_field_t,
            arg: *const *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_pb_callback_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pb_callback_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pb_callback_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_callback_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_callback_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pb_callback_s__bindgen_ty_1>())).decode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s__bindgen_ty_1),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pb_callback_s__bindgen_ty_1>())).encode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s__bindgen_ty_1),
            "::",
            stringify!(encode)
        )
    );
}
#[test]
fn bindgen_test_layout_pb_callback_s() {
    assert_eq!(
        ::std::mem::size_of::<pb_callback_s>(),
        16usize,
        concat!("Size of: ", stringify!(pb_callback_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_callback_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_callback_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_callback_s>())).funcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_callback_s>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s),
            "::",
            stringify!(arg)
        )
    );
}
extern "C" {
    pub fn pb_default_field_callback(
        istream: *mut pb_istream_t,
        ostream: *mut pb_ostream_t,
        field: *const pb_field_t,
    ) -> bool;
}
pub const pb_wire_type_t_PB_WT_VARINT: pb_wire_type_t = 0;
pub const pb_wire_type_t_PB_WT_64BIT: pb_wire_type_t = 1;
pub const pb_wire_type_t_PB_WT_STRING: pb_wire_type_t = 2;
pub const pb_wire_type_t_PB_WT_32BIT: pb_wire_type_t = 5;
pub const pb_wire_type_t_PB_WT_PACKED: pb_wire_type_t = 255;
pub type pb_wire_type_t = ::std::os::raw::c_uint;
pub type pb_extension_type_t = pb_extension_type_s;
pub type pb_extension_t = pb_extension_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_extension_type_s {
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_istream_t,
            extension: *mut pb_extension_t,
            tag: u32,
            wire_type: pb_wire_type_t,
        ) -> bool,
    >,
    pub encode: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut pb_ostream_t, extension: *const pb_extension_t) -> bool,
    >,
    pub arg: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_pb_extension_type_s() {
    assert_eq!(
        ::std::mem::size_of::<pb_extension_type_s>(),
        24usize,
        concat!("Size of: ", stringify!(pb_extension_type_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_extension_type_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_extension_type_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_extension_type_s>())).decode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_type_s),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_extension_type_s>())).encode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_type_s),
            "::",
            stringify!(encode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_extension_type_s>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_type_s),
            "::",
            stringify!(arg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_extension_s {
    pub type_: *const pb_extension_type_t,
    pub dest: *mut ::std::os::raw::c_void,
    pub next: *mut pb_extension_t,
    pub found: bool,
}
#[test]
fn bindgen_test_layout_pb_extension_s() {
    assert_eq!(
        ::std::mem::size_of::<pb_extension_s>(),
        32usize,
        concat!("Size of: ", stringify!(pb_extension_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_extension_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_extension_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_extension_s>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_extension_s>())).dest as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_extension_s>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_extension_s>())).found as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(found)
        )
    );
}
extern "C" {
    pub fn pb_field_iter_begin(
        iter: *mut pb_field_iter_t,
        desc: *const pb_msgdesc_t,
        message: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn pb_field_iter_begin_extension(
        iter: *mut pb_field_iter_t,
        extension: *mut pb_extension_t,
    ) -> bool;
}
extern "C" {
    pub fn pb_field_iter_begin_const(
        iter: *mut pb_field_iter_t,
        desc: *const pb_msgdesc_t,
        message: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn pb_field_iter_begin_extension_const(
        iter: *mut pb_field_iter_t,
        extension: *const pb_extension_t,
    ) -> bool;
}
extern "C" {
    pub fn pb_field_iter_next(iter: *mut pb_field_iter_t) -> bool;
}
extern "C" {
    pub fn pb_field_iter_find(iter: *mut pb_field_iter_t, tag: u32) -> bool;
}
extern "C" {
    pub fn pb_field_iter_find_extension(iter: *mut pb_field_iter_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_istream_s {
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut pb_istream_t, buf: *mut pb_byte_t, count: size_t) -> bool,
    >,
    pub state: *mut ::std::os::raw::c_void,
    pub bytes_left: size_t,
    pub errmsg: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pb_istream_s() {
    assert_eq!(
        ::std::mem::size_of::<pb_istream_s>(),
        32usize,
        concat!("Size of: ", stringify!(pb_istream_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_istream_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_istream_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_istream_s>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_istream_s),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_istream_s>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_istream_s),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_istream_s>())).bytes_left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_istream_s),
            "::",
            stringify!(bytes_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_istream_s>())).errmsg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_istream_s),
            "::",
            stringify!(errmsg)
        )
    );
}
extern "C" {
    pub fn pb_decode(
        stream: *mut pb_istream_t,
        fields: *const pb_msgdesc_t,
        dest_struct: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn pb_decode_ex(
        stream: *mut pb_istream_t,
        fields: *const pb_msgdesc_t,
        dest_struct: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Functions for manipulating streams *"]
    pub fn pb_istream_from_buffer(buf: *const pb_byte_t, bufsize: size_t) -> pb_istream_t;
}
extern "C" {
    pub fn pb_read(stream: *mut pb_istream_t, buf: *mut pb_byte_t, count: size_t) -> bool;
}
extern "C" {
    #[doc = " Helper functions for writing field callbacks *"]
    pub fn pb_decode_tag(
        stream: *mut pb_istream_t,
        wire_type: *mut pb_wire_type_t,
        tag: *mut u32,
        eof: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn pb_skip_field(stream: *mut pb_istream_t, wire_type: pb_wire_type_t) -> bool;
}
extern "C" {
    pub fn pb_decode_varint(stream: *mut pb_istream_t, dest: *mut u64) -> bool;
}
extern "C" {
    pub fn pb_decode_varint32(stream: *mut pb_istream_t, dest: *mut u32) -> bool;
}
extern "C" {
    pub fn pb_decode_bool(stream: *mut pb_istream_t, dest: *mut bool) -> bool;
}
extern "C" {
    pub fn pb_decode_svarint(stream: *mut pb_istream_t, dest: *mut i64) -> bool;
}
extern "C" {
    pub fn pb_decode_fixed32(stream: *mut pb_istream_t, dest: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn pb_decode_fixed64(stream: *mut pb_istream_t, dest: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn pb_make_string_substream(
        stream: *mut pb_istream_t,
        substream: *mut pb_istream_t,
    ) -> bool;
}
extern "C" {
    pub fn pb_close_string_substream(
        stream: *mut pb_istream_t,
        substream: *mut pb_istream_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_ostream_s {
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_ostream_t,
            buf: *const pb_byte_t,
            count: size_t,
        ) -> bool,
    >,
    pub state: *mut ::std::os::raw::c_void,
    pub max_size: size_t,
    pub bytes_written: size_t,
    pub errmsg: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pb_ostream_s() {
    assert_eq!(
        ::std::mem::size_of::<pb_ostream_s>(),
        40usize,
        concat!("Size of: ", stringify!(pb_ostream_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_ostream_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_ostream_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_ostream_s>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_ostream_s),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_ostream_s>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_ostream_s),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_ostream_s>())).max_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_ostream_s),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_ostream_s>())).bytes_written as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_ostream_s),
            "::",
            stringify!(bytes_written)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pb_ostream_s>())).errmsg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_ostream_s),
            "::",
            stringify!(errmsg)
        )
    );
}
extern "C" {
    pub fn pb_encode(
        stream: *mut pb_ostream_t,
        fields: *const pb_msgdesc_t,
        src_struct: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn pb_encode_ex(
        stream: *mut pb_ostream_t,
        fields: *const pb_msgdesc_t,
        src_struct: *const ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn pb_get_encoded_size(
        size: *mut size_t,
        fields: *const pb_msgdesc_t,
        src_struct: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Functions for manipulating streams *"]
    pub fn pb_ostream_from_buffer(buf: *mut pb_byte_t, bufsize: size_t) -> pb_ostream_t;
}
extern "C" {
    pub fn pb_write(stream: *mut pb_ostream_t, buf: *const pb_byte_t, count: size_t) -> bool;
}
extern "C" {
    #[doc = " Helper functions for writing field callbacks *"]
    pub fn pb_encode_tag_for_field(
        stream: *mut pb_ostream_t,
        field: *const pb_field_iter_t,
    ) -> bool;
}
extern "C" {
    pub fn pb_encode_tag(
        stream: *mut pb_ostream_t,
        wiretype: pb_wire_type_t,
        field_number: u32,
    ) -> bool;
}
extern "C" {
    pub fn pb_encode_varint(stream: *mut pb_ostream_t, value: u64) -> bool;
}
extern "C" {
    pub fn pb_encode_svarint(stream: *mut pb_ostream_t, value: i64) -> bool;
}
extern "C" {
    pub fn pb_encode_string(
        stream: *mut pb_ostream_t,
        buffer: *const pb_byte_t,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn pb_encode_fixed32(
        stream: *mut pb_ostream_t,
        value: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn pb_encode_fixed64(
        stream: *mut pb_ostream_t,
        value: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn pb_encode_submessage(
        stream: *mut pb_ostream_t,
        fields: *const pb_msgdesc_t,
        src_struct: *const ::std::os::raw::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Header {
    pub event_type: [::std::os::raw::c_char; 8usize],
    pub pub_id: [::std::os::raw::c_char; 8usize],
    pub token: [::std::os::raw::c_char; 160usize],
    pub pub_time: i64,
    pub event_id: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__Header() {
    assert_eq!(
        ::std::mem::size_of::<_Header>(),
        192usize,
        concat!("Size of: ", stringify!(_Header))
    );
    assert_eq!(
        ::std::mem::align_of::<_Header>(),
        8usize,
        concat!("Alignment of ", stringify!(_Header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Header>())).event_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Header),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Header>())).pub_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Header),
            "::",
            stringify!(pub_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Header>())).token as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Header),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Header>())).pub_time as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_Header),
            "::",
            stringify!(pub_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Header>())).event_id as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_Header),
            "::",
            stringify!(event_id)
        )
    );
}
pub type Header = _Header;
extern "C" {
    pub static Header_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Confirm_owner_t {
    pub size: pb_size_t,
    pub bytes: [pb_byte_t; 32usize],
}
#[test]
fn bindgen_test_layout_Confirm_owner_t() {
    assert_eq!(
        ::std::mem::size_of::<Confirm_owner_t>(),
        34usize,
        concat!("Size of: ", stringify!(Confirm_owner_t))
    );
    assert_eq!(
        ::std::mem::align_of::<Confirm_owner_t>(),
        2usize,
        concat!("Alignment of ", stringify!(Confirm_owner_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Confirm_owner_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Confirm_owner_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Confirm_owner_t>())).bytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Confirm_owner_t),
            "::",
            stringify!(bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Confirm_signature_t {
    pub size: pb_size_t,
    pub bytes: [pb_byte_t; 128usize],
}
#[test]
fn bindgen_test_layout_Confirm_signature_t() {
    assert_eq!(
        ::std::mem::size_of::<Confirm_signature_t>(),
        130usize,
        concat!("Size of: ", stringify!(Confirm_signature_t))
    );
    assert_eq!(
        ::std::mem::align_of::<Confirm_signature_t>(),
        2usize,
        concat!("Alignment of ", stringify!(Confirm_signature_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Confirm_signature_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Confirm_signature_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Confirm_signature_t>())).bytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Confirm_signature_t),
            "::",
            stringify!(bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Confirm {
    pub owner: Confirm_owner_t,
    pub timestamp: u32,
    pub signature: Confirm_signature_t,
    pub channel: u32,
}
#[test]
fn bindgen_test_layout__Confirm() {
    assert_eq!(
        ::std::mem::size_of::<_Confirm>(),
        176usize,
        concat!("Size of: ", stringify!(_Confirm))
    );
    assert_eq!(
        ::std::mem::align_of::<_Confirm>(),
        4usize,
        concat!("Alignment of ", stringify!(_Confirm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Confirm>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Confirm),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Confirm>())).timestamp as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_Confirm),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Confirm>())).signature as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_Confirm),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Confirm>())).channel as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_Confirm),
            "::",
            stringify!(channel)
        )
    );
}
pub type Confirm = _Confirm;
extern "C" {
    pub static Confirm_msg: pb_msgdesc_t;
}
pub const _Payload_UserDataType_Payload_UserDataType_JSON: _Payload_UserDataType = 0;
pub const _Payload_UserDataType_Payload_UserDataType_PB: _Payload_UserDataType = 1;
pub const _Payload_UserDataType_Payload_UserDataType_RAW: _Payload_UserDataType = 2;
pub type _Payload_UserDataType = ::std::os::raw::c_uint;
pub use self::_Payload_UserDataType as Payload_UserDataType;
pub const _Payload_PackageType_Payload_PackageType_UNKNOW: _Payload_PackageType = 0;
pub const _Payload_PackageType_Payload_PackageType_QUERY: _Payload_PackageType = 1;
pub const _Payload_PackageType_Payload_PackageType_COMFIRM: _Payload_PackageType = 2;
pub const _Payload_PackageType_Payload_PackageType_USERDATA: _Payload_PackageType = 3;
pub type _Payload_PackageType = ::std::os::raw::c_uint;
pub use self::_Payload_PackageType as Payload_PackageType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Payload_pubkey_t {
    pub size: pb_size_t,
    pub bytes: [pb_byte_t; 65usize],
}
#[test]
fn bindgen_test_layout_Payload_pubkey_t() {
    assert_eq!(
        ::std::mem::size_of::<Payload_pubkey_t>(),
        68usize,
        concat!("Size of: ", stringify!(Payload_pubkey_t))
    );
    assert_eq!(
        ::std::mem::align_of::<Payload_pubkey_t>(),
        2usize,
        concat!("Alignment of ", stringify!(Payload_pubkey_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Payload_pubkey_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Payload_pubkey_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Payload_pubkey_t>())).bytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Payload_pubkey_t),
            "::",
            stringify!(bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Payload_sign_t {
    pub size: pb_size_t,
    pub bytes: [pb_byte_t; 64usize],
}
#[test]
fn bindgen_test_layout_Payload_sign_t() {
    assert_eq!(
        ::std::mem::size_of::<Payload_sign_t>(),
        66usize,
        concat!("Size of: ", stringify!(Payload_sign_t))
    );
    assert_eq!(
        ::std::mem::align_of::<Payload_sign_t>(),
        2usize,
        concat!("Alignment of ", stringify!(Payload_sign_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Payload_sign_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Payload_sign_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Payload_sign_t>())).bytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Payload_sign_t),
            "::",
            stringify!(bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Payload_mac_t {
    pub size: pb_size_t,
    pub bytes: [pb_byte_t; 6usize],
}
#[test]
fn bindgen_test_layout_Payload_mac_t() {
    assert_eq!(
        ::std::mem::size_of::<Payload_mac_t>(),
        8usize,
        concat!("Size of: ", stringify!(Payload_mac_t))
    );
    assert_eq!(
        ::std::mem::align_of::<Payload_mac_t>(),
        2usize,
        concat!("Alignment of ", stringify!(Payload_mac_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Payload_mac_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Payload_mac_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Payload_mac_t>())).bytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Payload_mac_t),
            "::",
            stringify!(bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Payload_user_t {
    pub size: pb_size_t,
    pub bytes: [pb_byte_t; 320usize],
}
#[test]
fn bindgen_test_layout_Payload_user_t() {
    assert_eq!(
        ::std::mem::size_of::<Payload_user_t>(),
        322usize,
        concat!("Size of: ", stringify!(Payload_user_t))
    );
    assert_eq!(
        ::std::mem::align_of::<Payload_user_t>(),
        2usize,
        concat!("Alignment of ", stringify!(Payload_user_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Payload_user_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Payload_user_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Payload_user_t>())).bytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Payload_user_t),
            "::",
            stringify!(bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Payload {
    pub ptype: Payload_PackageType,
    pub pubkey: Payload_pubkey_t,
    pub sign: Payload_sign_t,
    pub mac: Payload_mac_t,
    pub dtype: Payload_UserDataType,
    pub user: Payload_user_t,
    pub has_pConfirm: bool,
    pub pConfirm: Confirm,
}
#[test]
fn bindgen_test_layout__Payload() {
    assert_eq!(
        ::std::mem::size_of::<_Payload>(),
        652usize,
        concat!("Size of: ", stringify!(_Payload))
    );
    assert_eq!(
        ::std::mem::align_of::<_Payload>(),
        4usize,
        concat!("Alignment of ", stringify!(_Payload))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Payload>())).ptype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Payload),
            "::",
            stringify!(ptype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Payload>())).pubkey as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Payload),
            "::",
            stringify!(pubkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Payload>())).sign as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_Payload),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Payload>())).mac as *const _ as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(_Payload),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Payload>())).dtype as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_Payload),
            "::",
            stringify!(dtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Payload>())).user as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_Payload),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Payload>())).has_pConfirm as *const _ as usize },
        474usize,
        concat!(
            "Offset of field: ",
            stringify!(_Payload),
            "::",
            stringify!(has_pConfirm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Payload>())).pConfirm as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(_Payload),
            "::",
            stringify!(pConfirm)
        )
    );
}
pub type Payload = _Payload;
extern "C" {
    pub static Payload_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Upload {
    pub has_header: bool,
    pub header: Header,
    pub has_payload: bool,
    pub payload: Payload,
}
#[test]
fn bindgen_test_layout__Upload() {
    assert_eq!(
        ::std::mem::size_of::<_Upload>(),
        856usize,
        concat!("Size of: ", stringify!(_Upload))
    );
    assert_eq!(
        ::std::mem::align_of::<_Upload>(),
        8usize,
        concat!("Alignment of ", stringify!(_Upload))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Upload>())).has_header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Upload),
            "::",
            stringify!(has_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Upload>())).header as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Upload),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Upload>())).has_payload as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_Upload),
            "::",
            stringify!(has_payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Upload>())).payload as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_Upload),
            "::",
            stringify!(payload)
        )
    );
}
pub type Upload = _Upload;
extern "C" {
    pub static Upload_msg: pb_msgdesc_t;
}
pub const MQTT_PUB_TOPIC_IOTEX_MQTT_QUERY_STATUS: MQTT_PUB_TOPIC = 0;
pub const MQTT_PUB_TOPIC_IOTEX_MQTT_PROPOSER: MQTT_PUB_TOPIC = 1;
pub const MQTT_PUB_TOPIC_IOTEX_MQTT_PUB_TOPICS: MQTT_PUB_TOPIC = 2;
pub type MQTT_PUB_TOPIC = ::std::os::raw::c_uint;
pub const UserData_Type_IOTEX_USER_DATA_TYPE_JSON: UserData_Type = 0;
pub const UserData_Type_IOTEX_USER_DATA_TYPE_PB: UserData_Type = 1;
pub const UserData_Type_IOTEX_USER_DATA_TYPE_RAW: UserData_Type = 2;
pub type UserData_Type = ::std::os::raw::c_uint;
pub type iotex_gettime = ::std::option::Option<unsafe extern "C" fn() -> time_t>;
pub type iotex_mqtt_pub = ::std::option::Option<
    unsafe extern "C" fn(
        topic: *mut ::std::os::raw::c_uchar,
        buf: *mut ::std::os::raw::c_uchar,
        buflen: ::std::os::raw::c_uint,
        qos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type iotex_mqtt_sub = ::std::option::Option<
    unsafe extern "C" fn(topic: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int,
>;
pub type iotex_sign_message = ::std::option::Option<
    unsafe extern "C" fn(
        input: *const u8,
        input_length: size_t,
        signature: *mut u8,
        signature_length: *mut size_t,
    ) -> ::std::os::raw::c_int,
>;
pub const IOTEX_MQTT_STATUS_IOTEX_MQTT_DISCONNECTED: IOTEX_MQTT_STATUS = 0;
pub const IOTEX_MQTT_STATUS_IOTEX_MQTT_CONNECTED: IOTEX_MQTT_STATUS = 1;
pub const IOTEX_MQTT_STATUS_IOTEX_MQTT_BIND_STATUS_OK: IOTEX_MQTT_STATUS = 2;
pub type IOTEX_MQTT_STATUS = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iotex_mqtt_ctx {
    pub status: IOTEX_MQTT_STATUS,
    pub topic: [[::std::os::raw::c_char; 64usize]; 1usize],
    pub token: [::std::os::raw::c_char; 160usize],
    pub mqtt_pub_func: iotex_mqtt_pub,
    pub mqtt_sub_func: iotex_mqtt_sub,
}
#[test]
fn bindgen_test_layout_iotex_mqtt_ctx() {
    assert_eq!(
        ::std::mem::size_of::<iotex_mqtt_ctx>(),
        248usize,
        concat!("Size of: ", stringify!(iotex_mqtt_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<iotex_mqtt_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(iotex_mqtt_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_mqtt_ctx>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_mqtt_ctx),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_mqtt_ctx>())).topic as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_mqtt_ctx),
            "::",
            stringify!(topic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_mqtt_ctx>())).token as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_mqtt_ctx),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_mqtt_ctx>())).mqtt_pub_func as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_mqtt_ctx),
            "::",
            stringify!(mqtt_pub_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_mqtt_ctx>())).mqtt_sub_func as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_mqtt_ctx),
            "::",
            stringify!(mqtt_sub_func)
        )
    );
}
pub type iotex_mqtt_ctx_t = iotex_mqtt_ctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iotex_crypto_ctx {
    pub wallet_addr: [::std::os::raw::c_uchar; 160usize],
    pub sign_value: [::std::os::raw::c_uchar; 68usize],
    pub sign_func: iotex_sign_message,
}
#[test]
fn bindgen_test_layout_iotex_crypto_ctx() {
    assert_eq!(
        ::std::mem::size_of::<iotex_crypto_ctx>(),
        240usize,
        concat!("Size of: ", stringify!(iotex_crypto_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<iotex_crypto_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(iotex_crypto_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_crypto_ctx>())).wallet_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_crypto_ctx),
            "::",
            stringify!(wallet_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_crypto_ctx>())).sign_value as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_crypto_ctx),
            "::",
            stringify!(sign_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_crypto_ctx>())).sign_func as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_crypto_ctx),
            "::",
            stringify!(sign_func)
        )
    );
}
pub type iotex_crypto_ctx_t = iotex_crypto_ctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iotex_dev_ctx {
    pub inited: ::std::os::raw::c_int,
    pub status: ::std::os::raw::c_int,
    pub debug_enable: ::std::os::raw::c_int,
    pub get_time_func: iotex_gettime,
    pub mqtt_ctx: iotex_mqtt_ctx_t,
    pub crypto_ctx: iotex_crypto_ctx_t,
}
#[test]
fn bindgen_test_layout_iotex_dev_ctx() {
    assert_eq!(
        ::std::mem::size_of::<iotex_dev_ctx>(),
        512usize,
        concat!("Size of: ", stringify!(iotex_dev_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<iotex_dev_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(iotex_dev_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_dev_ctx>())).inited as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_dev_ctx),
            "::",
            stringify!(inited)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_dev_ctx>())).status as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_dev_ctx),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_dev_ctx>())).debug_enable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_dev_ctx),
            "::",
            stringify!(debug_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_dev_ctx>())).get_time_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_dev_ctx),
            "::",
            stringify!(get_time_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_dev_ctx>())).mqtt_ctx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_dev_ctx),
            "::",
            stringify!(mqtt_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iotex_dev_ctx>())).crypto_ctx as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(iotex_dev_ctx),
            "::",
            stringify!(crypto_ctx)
        )
    );
}
pub type iotex_dev_ctx_t = iotex_dev_ctx;
extern "C" {
    pub fn iotex_dev_access_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_loop();
}
extern "C" {
    pub fn iotex_devreg_debug_enable(enable: ::std::os::raw::c_int);
}
extern "C" {
    pub fn iotex_dev_access_set_token(
        token: *const ::std::os::raw::c_char,
        token_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_set_mqtt_topic(
        topic: *const ::std::os::raw::c_char,
        topic_len: ::std::os::raw::c_int,
        topic_location: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_set_time_func(get_time_func: iotex_gettime) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_set_mqtt_func(
        mqtt_pub: iotex_mqtt_pub,
        mqtt_sub: iotex_mqtt_sub,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_set_sign_func(sign_func: iotex_sign_message) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_set_mqtt_status(status: IOTEX_MQTT_STATUS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_mqtt_input(
        topic: *mut u8,
        payload: *mut u8,
        len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_generate_dev_addr(
        public_key: *const ::std::os::raw::c_uchar,
        dev_address: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_data_upload_with_userdata(
        buf: *mut ::std::os::raw::c_void,
        buf_len: size_t,
        type_: UserData_Type,
        mac: *mut i8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_get_mqtt_connect_addr_in_format() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_dev_access_get_mqtt_connect_addr_in_url() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_dev_access_get_mqtt_connect_port() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_query_dev_register_status(mac: *mut i8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_dev_access_dev_register_confirm(mac: *mut i8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iotex_user_wallet_addr_set(
        buf: *mut ::std::os::raw::c_char,
        buf_len: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn InitLowsCalc();
}
extern "C" {
    pub fn LowsCalc(s: *mut ::std::os::raw::c_char, out: *mut ::std::os::raw::c_char);
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__low as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__high as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wseq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type jose_status_t = ::std::os::raw::c_int;
pub const JWS_USAGE_JWS_USAGE_DIDCOMM: JWS_USAGE = 0;
pub const JWS_USAGE_JWS_USAGE_JWT: JWS_USAGE = 1;
pub const JWS_USAGE_JWS_USAGE_JSON: JWS_USAGE = 2;
pub const JWS_USAGE_JWS_USAGE_COMPACT: JWS_USAGE = 3;
pub type JWS_USAGE = ::std::os::raw::c_uint;
pub type Base64url = ::std::os::raw::c_char;
pub const JWKRegistryType_JWKREGISTRYTYPE_OWNER: JWKRegistryType = 0;
pub const JWKRegistryType_JWKREGISTRYTYPE_PEER: JWKRegistryType = 1;
pub type JWKRegistryType = ::std::os::raw::c_uint;
pub const JWAlogrithm_None: JWAlogrithm = 0;
pub const JWAlogrithm_HS256: JWAlogrithm = 1;
pub const JWAlogrithm_HS384: JWAlogrithm = 2;
pub const JWAlogrithm_HS512: JWAlogrithm = 3;
pub const JWAlogrithm_RS256: JWAlogrithm = 4;
pub const JWAlogrithm_RS384: JWAlogrithm = 5;
pub const JWAlogrithm_RS512: JWAlogrithm = 6;
pub const JWAlogrithm_PS256: JWAlogrithm = 7;
pub const JWAlogrithm_PS384: JWAlogrithm = 8;
pub const JWAlogrithm_PS512: JWAlogrithm = 9;
pub const JWAlogrithm_EdDSA: JWAlogrithm = 10;
pub const JWAlogrithm_ES256: JWAlogrithm = 11;
pub const JWAlogrithm_ES384: JWAlogrithm = 12;
pub const JWAlogrithm_ES256K: JWAlogrithm = 13;
pub const JWAlogrithm_ES256KR: JWAlogrithm = 14;
pub type JWAlogrithm = ::std::os::raw::c_uint;
pub const JWKType_JWKTYPE_EC: JWKType = 1;
pub const JWKType_JWKTYPE_RSA: JWKType = 2;
pub const JWKType_JWKTYPE_Symmetric: JWKType = 3;
pub const JWKType_JWKTYPE_OKP: JWKType = 4;
pub type JWKType = ::std::os::raw::c_uint;
pub const KnownKeyAlg_Ed25519: KnownKeyAlg = 0;
pub const KnownKeyAlg_X25519: KnownKeyAlg = 1;
pub const KnownKeyAlg_P256: KnownKeyAlg = 2;
pub const KnownKeyAlg_K256: KnownKeyAlg = 3;
pub const KnownKeyAlg_Unsupported: KnownKeyAlg = 4;
pub type KnownKeyAlg = ::std::os::raw::c_uint;
pub const JWKSupportKeyAlg_JWK_SUPPORT_KEY_ALG_ED25519: JWKSupportKeyAlg = 0;
pub const JWKSupportKeyAlg_JWK_SUPPORT_KEY_ALG_P256: JWKSupportKeyAlg = 1;
pub const JWKSupportKeyAlg_JWK_SUPPORT_KEY_ALG_K256: JWKSupportKeyAlg = 2;
pub type JWKSupportKeyAlg = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ECParams {
    pub crv: [::std::os::raw::c_char; 12usize],
    pub x_coordinate: [Base64url; 48usize],
    pub y_coordinate: [Base64url; 48usize],
    pub ecc_private_key: [Base64url; 48usize],
}
#[test]
fn bindgen_test_layout__ECParams() {
    assert_eq!(
        ::std::mem::size_of::<_ECParams>(),
        156usize,
        concat!("Size of: ", stringify!(_ECParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_ECParams>(),
        1usize,
        concat!("Alignment of ", stringify!(_ECParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ECParams>())).crv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ECParams),
            "::",
            stringify!(crv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ECParams>())).x_coordinate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ECParams),
            "::",
            stringify!(x_coordinate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ECParams>())).y_coordinate as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ECParams),
            "::",
            stringify!(y_coordinate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ECParams>())).ecc_private_key as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_ECParams),
            "::",
            stringify!(ecc_private_key)
        )
    );
}
pub type ECParams = _ECParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RSAParams {
    pub RSAParams_todo: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_RSAParams() {
    assert_eq!(
        ::std::mem::size_of::<RSAParams>(),
        8usize,
        concat!("Size of: ", stringify!(RSAParams))
    );
    assert_eq!(
        ::std::mem::align_of::<RSAParams>(),
        8usize,
        concat!("Alignment of ", stringify!(RSAParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RSAParams>())).RSAParams_todo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RSAParams),
            "::",
            stringify!(RSAParams_todo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SymmetricParams {
    pub SymmetricParams_todo: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SymmetricParams() {
    assert_eq!(
        ::std::mem::size_of::<SymmetricParams>(),
        8usize,
        concat!("Size of: ", stringify!(SymmetricParams))
    );
    assert_eq!(
        ::std::mem::align_of::<SymmetricParams>(),
        8usize,
        concat!("Alignment of ", stringify!(SymmetricParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SymmetricParams>())).SymmetricParams_todo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SymmetricParams),
            "::",
            stringify!(SymmetricParams_todo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OctetParams {
    pub crv: [::std::os::raw::c_char; 12usize],
    pub public_key: *mut Base64url,
    pub private_key: *mut Base64url,
}
#[test]
fn bindgen_test_layout_OctetParams() {
    assert_eq!(
        ::std::mem::size_of::<OctetParams>(),
        32usize,
        concat!("Size of: ", stringify!(OctetParams))
    );
    assert_eq!(
        ::std::mem::align_of::<OctetParams>(),
        8usize,
        concat!("Alignment of ", stringify!(OctetParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OctetParams>())).crv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OctetParams),
            "::",
            stringify!(crv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OctetParams>())).public_key as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OctetParams),
            "::",
            stringify!(public_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OctetParams>())).private_key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OctetParams),
            "::",
            stringify!(private_key)
        )
    );
}
pub const JWKPublickeyUseParams_JWKPubKeyUseNone: JWKPublickeyUseParams = 0;
pub const JWKPublickeyUseParams_JWKPubKeyUseSIG: JWKPublickeyUseParams = 1;
pub const JWKPublickeyUseParams_JWKPubKeyUseENC: JWKPublickeyUseParams = 2;
pub type JWKPublickeyUseParams = ::std::os::raw::c_uint;
pub const JWKKeyOpsParams_JWKKeyOpsNone: JWKKeyOpsParams = 0;
pub const JWKKeyOpsParams_JWKKeyOpsSign: JWKKeyOpsParams = 1;
pub const JWKKeyOpsParams_JWKKeyOpsVerigy: JWKKeyOpsParams = 2;
pub const JWKKeyOpsParams_JWKKeyOpsEncrypt: JWKKeyOpsParams = 3;
pub const JWKKeyOpsParams_JWKKeyOpsDecrypt: JWKKeyOpsParams = 4;
pub const JWKKeyOpsParams_JWKKeyOpsWrapKey: JWKKeyOpsParams = 5;
pub const JWKKeyOpsParams_JWKKeyOpsUnWrapKey: JWKKeyOpsParams = 6;
pub const JWKKeyOpsParams_JWKKeyOpsDeriveKey: JWKKeyOpsParams = 7;
pub const JWKKeyOpsParams_JWKKeyOpsDeriveBits: JWKKeyOpsParams = 8;
pub type JWKKeyOpsParams = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JWK {
    pub public_key_use: JWKPublickeyUseParams,
    pub key_operations: JWKKeyOpsParams,
    pub key_id: ::std::os::raw::c_uint,
    pub x509_url: *mut ::std::os::raw::c_char,
    pub x509_certificate_chain: *mut ::std::os::raw::c_char,
    pub x509_thumbprint_sha1: [Base64url; 28usize],
    pub x509_thumbprint_sha256: [Base64url; 44usize],
    pub alg: JWAlogrithm,
    pub type_: JWKType,
    pub Params: JWK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JWK__bindgen_ty_1 {
    pub ec: ECParams,
    pub rsa: RSAParams,
    pub oct: SymmetricParams,
    pub okp: OctetParams,
}
#[test]
fn bindgen_test_layout_JWK__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<JWK__bindgen_ty_1>(),
        160usize,
        concat!("Size of: ", stringify!(JWK__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<JWK__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(JWK__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK__bindgen_ty_1>())).ec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK__bindgen_ty_1),
            "::",
            stringify!(ec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK__bindgen_ty_1>())).rsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK__bindgen_ty_1),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK__bindgen_ty_1>())).oct as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK__bindgen_ty_1),
            "::",
            stringify!(oct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK__bindgen_ty_1>())).okp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK__bindgen_ty_1),
            "::",
            stringify!(okp)
        )
    );
}
#[test]
fn bindgen_test_layout_JWK() {
    assert_eq!(
        ::std::mem::size_of::<JWK>(),
        272usize,
        concat!("Size of: ", stringify!(JWK))
    );
    assert_eq!(
        ::std::mem::align_of::<JWK>(),
        8usize,
        concat!("Alignment of ", stringify!(JWK))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK>())).public_key_use as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK),
            "::",
            stringify!(public_key_use)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK>())).key_operations as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK),
            "::",
            stringify!(key_operations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK>())).key_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK>())).x509_url as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK),
            "::",
            stringify!(x509_url)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK>())).x509_certificate_chain as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK),
            "::",
            stringify!(x509_certificate_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK>())).x509_thumbprint_sha1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK),
            "::",
            stringify!(x509_thumbprint_sha1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK>())).x509_thumbprint_sha256 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK),
            "::",
            stringify!(x509_thumbprint_sha256)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK>())).alg as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(JWK), "::", stringify!(alg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK>())).type_ as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JWK>())).Params as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(JWK),
            "::",
            stringify!(Params)
        )
    );
}
extern "C" {
    pub fn iotex_jwk_get_algorithm(jwk: *mut JWK) -> JWAlogrithm;
}
extern "C" {
    pub fn iotex_jwk_get_key_alg(jwk: *mut JWK) -> KnownKeyAlg;
}
extern "C" {
    pub fn iotex_jwk_copy(jwk: *mut JWK, skipPrivate: bool) -> *mut JWK;
}
extern "C" {
    pub fn iotex_jwk_to_public(jwk: *mut JWK) -> *mut JWK;
}
extern "C" {
    pub fn iotex_jwk_generate(
        type_: JWKType,
        keyalg: JWKSupportKeyAlg,
        lifetime: ::std::os::raw::c_int,
        key_usage: ::std::os::raw::c_uint,
        alg: ::std::os::raw::c_uint,
        key_id: *mut ::std::os::raw::c_uint,
    ) -> *mut JWK;
}
extern "C" {
    pub fn iotex_jwk_generate_by_secret(
        secret: *mut u8,
        secret_size: ::std::os::raw::c_uint,
        type_: JWKType,
        keyalg: JWKSupportKeyAlg,
        lifetime: ::std::os::raw::c_int,
        key_usage: ::std::os::raw::c_uint,
        alg: ::std::os::raw::c_uint,
        key_id: *mut ::std::os::raw::c_uint,
    ) -> *mut JWK;
}
extern "C" {
    pub fn iotex_jwk_get_jwk_from_json_value(json_value: *mut ::std::os::raw::c_void) -> *mut JWK;
}
extern "C" {
    pub fn _did_jwk_json_generate(jwk: *mut JWK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn iotex_jwk_destroy(jwk: *mut JWK);
}
extern "C" {
    pub fn iotex_jwk_serialize(jwk: *mut JWK, format: bool) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_jwk_generate_kid(
        method: *mut ::std::os::raw::c_char,
        jwk: *mut JWK,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_jwk_equals(jwk1: *mut JWK, jwk2: *mut JWK, skipPri: bool) -> bool;
}
extern "C" {
    pub fn iotex_jwk_get_pubkey_from_jwk(
        jwk: *mut JWK,
        outdata: *mut ::std::os::raw::c_char,
        outdata_len: *mut size_t,
    ) -> jose_status_t;
}
extern "C" {
    pub fn iotex_pubkey_uncompress_convert_compress(
        uncompress: *const ::std::os::raw::c_char,
        compress: *mut ::std::os::raw::c_char,
    ) -> jose_status_t;
}
extern "C" {
    pub fn iotex_jwk_get_psa_key_id_from_didurl(
        didurl: *mut ::std::os::raw::c_char,
    ) -> psa_key_id_t;
}
pub type jws_handle_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JWSCompactHeader {
    pub typ: *mut ::std::os::raw::c_char,
    pub alg: JWAlogrithm,
    pub kid: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__JWSCompactHeader() {
    assert_eq!(
        ::std::mem::size_of::<_JWSCompactHeader>(),
        24usize,
        concat!("Size of: ", stringify!(_JWSCompactHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<_JWSCompactHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(_JWSCompactHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWSCompactHeader>())).typ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWSCompactHeader),
            "::",
            stringify!(typ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWSCompactHeader>())).alg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWSCompactHeader),
            "::",
            stringify!(alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWSCompactHeader>())).kid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWSCompactHeader),
            "::",
            stringify!(kid)
        )
    );
}
pub type JWSCompactHeader = _JWSCompactHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JWSHeader {
    pub kid: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__JWSHeader() {
    assert_eq!(
        ::std::mem::size_of::<_JWSHeader>(),
        8usize,
        concat!("Size of: ", stringify!(_JWSHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<_JWSHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(_JWSHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWSHeader>())).kid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWSHeader),
            "::",
            stringify!(kid)
        )
    );
}
pub type JWSHeader = _JWSHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JWSProtectedHeader {
    pub typ: [::std::os::raw::c_char; 32usize],
    pub alg: JWAlogrithm,
}
#[test]
fn bindgen_test_layout__JWSProtectedHeader() {
    assert_eq!(
        ::std::mem::size_of::<_JWSProtectedHeader>(),
        36usize,
        concat!("Size of: ", stringify!(_JWSProtectedHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<_JWSProtectedHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(_JWSProtectedHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWSProtectedHeader>())).typ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWSProtectedHeader),
            "::",
            stringify!(typ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWSProtectedHeader>())).alg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWSProtectedHeader),
            "::",
            stringify!(alg)
        )
    );
}
pub type JWSProtectedHeader = _JWSProtectedHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JWSSignature {
    pub header: *mut JWSHeader,
    pub _protected: *mut ::std::os::raw::c_char,
    pub signature: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__JWSSignature() {
    assert_eq!(
        ::std::mem::size_of::<_JWSSignature>(),
        24usize,
        concat!("Size of: ", stringify!(_JWSSignature))
    );
    assert_eq!(
        ::std::mem::align_of::<_JWSSignature>(),
        8usize,
        concat!("Alignment of ", stringify!(_JWSSignature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWSSignature>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWSSignature),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWSSignature>()))._protected as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWSSignature),
            "::",
            stringify!(_protected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWSSignature>())).signature as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWSSignature),
            "::",
            stringify!(signature)
        )
    );
}
pub type JWSSignature = _JWSSignature;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JWS {
    pub signatures: [*mut JWSSignature; 4usize],
    pub payload: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__JWS() {
    assert_eq!(
        ::std::mem::size_of::<_JWS>(),
        40usize,
        concat!("Size of: ", stringify!(_JWS))
    );
    assert_eq!(
        ::std::mem::align_of::<_JWS>(),
        8usize,
        concat!("Alignment of ", stringify!(_JWS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWS>())).signatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWS),
            "::",
            stringify!(signatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWS>())).payload as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWS),
            "::",
            stringify!(payload)
        )
    );
}
pub type JWS = _JWS;
extern "C" {
    pub fn iotex_jws_compact_serialize(
        alg: JWAlogrithm,
        plaintext: *mut ::std::os::raw::c_char,
        plaintext_size: size_t,
        jwk: *mut JWK,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_jws_general_json_serialize_init(
        plaintext: *mut ::std::os::raw::c_char,
        plaintext_size: size_t,
    ) -> jws_handle_t;
}
extern "C" {
    pub fn iotex_jws_general_json_serialize_update(
        handle: jws_handle_t,
        alg: JWAlogrithm,
        kid: *mut ::std::os::raw::c_char,
        jwk: *mut JWK,
    ) -> jose_status_t;
}
extern "C" {
    pub fn iotex_jws_general_json_serialize_finish(
        handle: jws_handle_t,
        format: bool,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_jws_flattened_json_serialize(
        alg: JWAlogrithm,
        plaintext: *mut ::std::os::raw::c_char,
        plaintext_size: size_t,
        kid: *mut ::std::os::raw::c_char,
        usage: JWS_USAGE,
        jwk: *mut JWK,
        format: bool,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_jws_compact_verify(
        alg: JWAlogrithm,
        jws_msg: *mut ::std::os::raw::c_char,
        jwk: *mut JWK,
    ) -> bool;
}
extern "C" {
    pub fn _find_point_position(
        jws: *mut ::std::os::raw::c_char,
        first: *mut u32,
        second: *mut u32,
    ) -> jose_status_t;
}
pub const EncAlgorithm_A256cbcHs512: EncAlgorithm = 0;
pub const EncAlgorithm_Xc20P: EncAlgorithm = 1;
pub const EncAlgorithm_A256Gcm: EncAlgorithm = 2;
pub type EncAlgorithm = ::std::os::raw::c_uint;
pub const KWAlgorithms_Ecdh1puA256kw: KWAlgorithms = 0;
pub const KWAlgorithms_EcdhEsA256kw: KWAlgorithms = 1;
pub type KWAlgorithms = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PerRecipientHeader {
    pub kid: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__PerRecipientHeader() {
    assert_eq!(
        ::std::mem::size_of::<_PerRecipientHeader>(),
        8usize,
        concat!("Size of: ", stringify!(_PerRecipientHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<_PerRecipientHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(_PerRecipientHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PerRecipientHeader>())).kid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PerRecipientHeader),
            "::",
            stringify!(kid)
        )
    );
}
pub type PerRecipientHeader = _PerRecipientHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Recipient {
    pub header: PerRecipientHeader,
    pub encrypted_key: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__Recipient() {
    assert_eq!(
        ::std::mem::size_of::<_Recipient>(),
        16usize,
        concat!("Size of: ", stringify!(_Recipient))
    );
    assert_eq!(
        ::std::mem::align_of::<_Recipient>(),
        8usize,
        concat!("Alignment of ", stringify!(_Recipient))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Recipient>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Recipient),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Recipient>())).encrypted_key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Recipient),
            "::",
            stringify!(encrypted_key)
        )
    );
}
pub type Recipient = _Recipient;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JweProtectedHeader {
    pub typ: *mut ::std::os::raw::c_char,
    pub alg: KWAlgorithms,
    pub enc: EncAlgorithm,
    pub skid: *mut ::std::os::raw::c_char,
    pub apu: *mut ::std::os::raw::c_char,
    pub apv: *mut ::std::os::raw::c_char,
    pub epk: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__JweProtectedHeader() {
    assert_eq!(
        ::std::mem::size_of::<_JweProtectedHeader>(),
        48usize,
        concat!("Size of: ", stringify!(_JweProtectedHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<_JweProtectedHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(_JweProtectedHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JweProtectedHeader>())).typ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JweProtectedHeader),
            "::",
            stringify!(typ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JweProtectedHeader>())).alg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JweProtectedHeader),
            "::",
            stringify!(alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JweProtectedHeader>())).enc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_JweProtectedHeader),
            "::",
            stringify!(enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JweProtectedHeader>())).skid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JweProtectedHeader),
            "::",
            stringify!(skid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JweProtectedHeader>())).apu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JweProtectedHeader),
            "::",
            stringify!(apu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JweProtectedHeader>())).apv as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JweProtectedHeader),
            "::",
            stringify!(apv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JweProtectedHeader>())).epk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JweProtectedHeader),
            "::",
            stringify!(epk)
        )
    );
}
pub type JweProtectedHeader = _JweProtectedHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JWE {
    pub _protected: *mut ::std::os::raw::c_char,
    pub iv: *mut ::std::os::raw::c_char,
    pub ciphertext: *mut ::std::os::raw::c_char,
    pub tag: *mut ::std::os::raw::c_char,
    pub recipients: [*mut Recipient; 4usize],
}
#[test]
fn bindgen_test_layout__JWE() {
    assert_eq!(
        ::std::mem::size_of::<_JWE>(),
        64usize,
        concat!("Size of: ", stringify!(_JWE))
    );
    assert_eq!(
        ::std::mem::align_of::<_JWE>(),
        8usize,
        concat!("Alignment of ", stringify!(_JWE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWE>()))._protected as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWE),
            "::",
            stringify!(_protected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWE>())).iv as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_JWE), "::", stringify!(iv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWE>())).ciphertext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWE),
            "::",
            stringify!(ciphertext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWE>())).tag as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_JWE), "::", stringify!(tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWE>())).recipients as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWE),
            "::",
            stringify!(recipients)
        )
    );
}
pub type JWE = _JWE;
extern "C" {
    pub fn iotex_jwe_encrypt_plaintext(
        key_id: psa_key_id_t,
        plaintext: *mut ::std::os::raw::c_char,
        pLen: size_t,
        nonce: *mut ::std::os::raw::c_char,
        nonce_len: size_t,
        ad: *mut ::std::os::raw::c_char,
        ad_len: size_t,
        ciphertext_length: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_jwe_encrypt_protected(
        KwAlg: KWAlgorithms,
        enAlg: EncAlgorithm,
        sender: *mut ::std::os::raw::c_char,
        recipients_kid: *mut *mut ::std::os::raw::c_char,
        epk: *mut JWK,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_jwe_encrypt(
        plaintext: *mut ::std::os::raw::c_char,
        alg: KWAlgorithms,
        enc: EncAlgorithm,
        sender: *mut ::std::os::raw::c_char,
        sJWK: *mut JWK,
        recipients_kid: *mut *mut ::std::os::raw::c_char,
        format: bool,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_jwe_decrypt(
        jwe_serialize: *mut ::std::os::raw::c_char,
        alg: KWAlgorithms,
        enc: EncAlgorithm,
        sender: *mut ::std::os::raw::c_char,
        sJWK: *mut JWK,
        recipients_kid: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JWTClaim {
    pub iss: *mut ::std::os::raw::c_char,
    pub sub: *mut ::std::os::raw::c_char,
    pub aud: *mut ::std::os::raw::c_char,
    pub exp: time_t,
    pub nbf: time_t,
    pub iat: time_t,
    pub jti: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__JWTClaim() {
    assert_eq!(
        ::std::mem::size_of::<_JWTClaim>(),
        56usize,
        concat!("Size of: ", stringify!(_JWTClaim))
    );
    assert_eq!(
        ::std::mem::align_of::<_JWTClaim>(),
        8usize,
        concat!("Alignment of ", stringify!(_JWTClaim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWTClaim>())).iss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWTClaim),
            "::",
            stringify!(iss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWTClaim>())).sub as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWTClaim),
            "::",
            stringify!(sub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWTClaim>())).aud as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWTClaim),
            "::",
            stringify!(aud)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWTClaim>())).exp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWTClaim),
            "::",
            stringify!(exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWTClaim>())).nbf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWTClaim),
            "::",
            stringify!(nbf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWTClaim>())).iat as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWTClaim),
            "::",
            stringify!(iat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWTClaim>())).jti as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWTClaim),
            "::",
            stringify!(jti)
        )
    );
}
pub type JWTClaim = _JWTClaim;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JWTClaim_handle {
    pub claim: *mut cJSON,
}
#[test]
fn bindgen_test_layout__JWTClaim_handle() {
    assert_eq!(
        ::std::mem::size_of::<_JWTClaim_handle>(),
        8usize,
        concat!("Size of: ", stringify!(_JWTClaim_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<_JWTClaim_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(_JWTClaim_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JWTClaim_handle>())).claim as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JWTClaim_handle),
            "::",
            stringify!(claim)
        )
    );
}
pub type JWTClaim_handle = *mut _JWTClaim_handle;
pub const JWTClaimType_JWT_CLAIM_TYPE_ISS: JWTClaimType = 0;
pub const JWTClaimType_JWT_CLAIM_TYPE_SUB: JWTClaimType = 1;
pub const JWTClaimType_JWT_CLAIM_TYPE_AUD: JWTClaimType = 2;
pub const JWTClaimType_JWT_CLAIM_TYPE_EXP: JWTClaimType = 3;
pub const JWTClaimType_JWT_CLAIM_TYPE_NBF: JWTClaimType = 4;
pub const JWTClaimType_JWT_CLAIM_TYPE_IAT: JWTClaimType = 5;
pub const JWTClaimType_JWT_CLAIM_TYPE_JTI: JWTClaimType = 6;
pub const JWTClaimType_JWT_CLAIM_TYPE_PRIVATE_STRING: JWTClaimType = 7;
pub const JWTClaimType_JWT_CLAIM_TYPE_PRIVATE_NUM: JWTClaimType = 8;
pub const JWTClaimType_JWT_CLAIM_TYPE_PRIVATE_BOOL: JWTClaimType = 9;
pub const JWTClaimType_JWT_CLAIM_TYPE_PRIVATE_JSON: JWTClaimType = 10;
pub type JWTClaimType = ::std::os::raw::c_uint;
pub const JWTType_JWT_TYPE_JWS: JWTType = 0;
pub const JWTType_JWT_TYPE_JWE: JWTType = 1;
pub type JWTType = ::std::os::raw::c_uint;
extern "C" {
    pub fn iotex_jwt_claim_new() -> JWTClaim_handle;
}
extern "C" {
    pub fn iotex_jwt_claim_destroy(handle: JWTClaim_handle);
}
extern "C" {
    pub fn iotex_jwt_claim_set_value(
        handle: JWTClaim_handle,
        type_: JWTClaimType,
        name: *mut ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> jose_status_t;
}
extern "C" {
    pub fn iotex_jwt_claim_get_value(
        jwt_serialize: *mut ::std::os::raw::c_char,
        jwt_type: JWTType,
        type_: JWTClaimType,
        name: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn iotex_jwt_claim_serialize(
        handle: JWTClaim_handle,
        format: bool,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_jwt_serialize(
        handle: JWTClaim_handle,
        type_: JWTType,
        alg: JWAlogrithm,
        jwk: *mut JWK,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_jwt_verify(
        jwt_serialize: *mut ::std::os::raw::c_char,
        type_: JWTType,
        alg: JWAlogrithm,
        jwk: *mut JWK,
    ) -> bool;
}
pub type did_status_t = ::std::os::raw::c_int;
pub type DID = *mut ::std::os::raw::c_char;
pub type diddoc_handle_t = ::std::os::raw::c_uint;
pub type diddoc_property_handle_t = *mut cJSON;
pub type VerificationMethod_Map = *mut cJSON;
pub const VerificationMethod_Purpose_VM_PURPOSE_VERIFICATION_METHOD: VerificationMethod_Purpose = 0;
pub const VerificationMethod_Purpose_VM_PURPOSE_AUTHENTICATION: VerificationMethod_Purpose = 1;
pub const VerificationMethod_Purpose_VM_PURPOSE_ASSERTION_METHOD: VerificationMethod_Purpose = 2;
pub const VerificationMethod_Purpose_VM_PURPOSE_KEY_AGREEMENT: VerificationMethod_Purpose = 3;
pub const VerificationMethod_Purpose_VM_PURPOSE_CAPABILITY_INVOCATION: VerificationMethod_Purpose =
    4;
pub const VerificationMethod_Purpose_VM_PURPOSE_CAPABILITY_DELEGATION: VerificationMethod_Purpose =
    5;
pub const VerificationMethod_Purpose_VM_PURPOSE_PUBLIC_KEY: VerificationMethod_Purpose = 6;
pub const VerificationMethod_Purpose_VM_PURPOSE_MAX: VerificationMethod_Purpose = 7;
pub type VerificationMethod_Purpose = ::std::os::raw::c_uint;
pub const VerificationMethod_Type_VM_TYPE_DIDURL: VerificationMethod_Type = 0;
pub const VerificationMethod_Type_VM_TYPE_RELATIVEDIDURL: VerificationMethod_Type = 1;
pub const VerificationMethod_Type_VM_TYPE_MAP: VerificationMethod_Type = 2;
pub type VerificationMethod_Type = ::std::os::raw::c_uint;
pub const ServiceEndpoint_type_SERVICE_ENDPOINT_TYPE_URI: ServiceEndpoint_type = 0;
pub const ServiceEndpoint_type_SERVICE_ENDPOINT_TYPE_MAP: ServiceEndpoint_type = 1;
pub type ServiceEndpoint_type = ::std::os::raw::c_uint;
pub const VerificationMethod_TypeValue_VMTypeNone: VerificationMethod_TypeValue = 0;
pub const VerificationMethod_TypeValue_JsonWebKey2020: VerificationMethod_TypeValue = 1;
pub const VerificationMethod_TypeValue_EcdsaSecp256k1VerificationKey2019:
    VerificationMethod_TypeValue = 2;
pub const VerificationMethod_TypeValue_Ed25519VerificationKey2018: VerificationMethod_TypeValue = 3;
pub const VerificationMethod_TypeValue_Bls12381G1Key2020: VerificationMethod_TypeValue = 4;
pub const VerificationMethod_TypeValue_Bls12381G2Key2020: VerificationMethod_TypeValue = 5;
pub const VerificationMethod_TypeValue_PgpVerificationKey2021: VerificationMethod_TypeValue = 6;
pub const VerificationMethod_TypeValue_RsaVerificationKey2018: VerificationMethod_TypeValue = 7;
pub type VerificationMethod_TypeValue = ::std::os::raw::c_uint;
pub const VerificationMethod_PublicKeyType_VERIFICATION_METHOD_PUBLIC_KEY_TYPE_JWK:
    VerificationMethod_PublicKeyType = 0;
pub const VerificationMethod_PublicKeyType_VERIFICATION_METHOD_PUBLIC_KEY_TYPE_MULTIBASE:
    VerificationMethod_PublicKeyType = 1;
pub const VerificationMethod_PublicKeyType_VERIFICATION_METHOD_PUBLIC_KEY_TYPE_BASE58:
    VerificationMethod_PublicKeyType = 2;
pub type VerificationMethod_PublicKeyType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DID_Contexts {
    pub contexts: *mut cJSON,
}
#[test]
fn bindgen_test_layout__DID_Contexts() {
    assert_eq!(
        ::std::mem::size_of::<_DID_Contexts>(),
        8usize,
        concat!("Size of: ", stringify!(_DID_Contexts))
    );
    assert_eq!(
        ::std::mem::align_of::<_DID_Contexts>(),
        8usize,
        concat!("Alignment of ", stringify!(_DID_Contexts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DID_Contexts>())).contexts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DID_Contexts),
            "::",
            stringify!(contexts)
        )
    );
}
pub type DIDDoc_Contexts = _DID_Contexts;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DID_AlsoKnownAs {
    pub alsoKnownAs: *mut cJSON,
}
#[test]
fn bindgen_test_layout__DID_AlsoKnownAs() {
    assert_eq!(
        ::std::mem::size_of::<_DID_AlsoKnownAs>(),
        8usize,
        concat!("Size of: ", stringify!(_DID_AlsoKnownAs))
    );
    assert_eq!(
        ::std::mem::align_of::<_DID_AlsoKnownAs>(),
        8usize,
        concat!("Alignment of ", stringify!(_DID_AlsoKnownAs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DID_AlsoKnownAs>())).alsoKnownAs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DID_AlsoKnownAs),
            "::",
            stringify!(alsoKnownAs)
        )
    );
}
pub type DIDDoc_AlsoKnownAs = _DID_AlsoKnownAs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DID_Controller {
    pub controllers: *mut cJSON,
}
#[test]
fn bindgen_test_layout__DID_Controller() {
    assert_eq!(
        ::std::mem::size_of::<_DID_Controller>(),
        8usize,
        concat!("Size of: ", stringify!(_DID_Controller))
    );
    assert_eq!(
        ::std::mem::align_of::<_DID_Controller>(),
        8usize,
        concat!("Alignment of ", stringify!(_DID_Controller))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DID_Controller>())).controllers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DID_Controller),
            "::",
            stringify!(controllers)
        )
    );
}
pub type DIDDoc_Controllers = _DID_Controller;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DIDDoc_VerificationMethod {
    pub purpose: VerificationMethod_Purpose,
    pub type_: VerificationMethod_Type,
    pub vm: *mut cJSON,
}
#[test]
fn bindgen_test_layout__DIDDoc_VerificationMethod() {
    assert_eq!(
        ::std::mem::size_of::<_DIDDoc_VerificationMethod>(),
        16usize,
        concat!("Size of: ", stringify!(_DIDDoc_VerificationMethod))
    );
    assert_eq!(
        ::std::mem::align_of::<_DIDDoc_VerificationMethod>(),
        8usize,
        concat!("Alignment of ", stringify!(_DIDDoc_VerificationMethod))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_DIDDoc_VerificationMethod>())).purpose as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc_VerificationMethod),
            "::",
            stringify!(purpose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_DIDDoc_VerificationMethod>())).type_ as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc_VerificationMethod),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc_VerificationMethod>())).vm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc_VerificationMethod),
            "::",
            stringify!(vm)
        )
    );
}
pub type DIDDoc_VerificationMethod = _DIDDoc_VerificationMethod;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DIDDoc_ServicEndpoint {
    pub type_: ServiceEndpoint_type,
    pub endpoint: *mut cJSON,
}
#[test]
fn bindgen_test_layout__DIDDoc_ServicEndpoint() {
    assert_eq!(
        ::std::mem::size_of::<_DIDDoc_ServicEndpoint>(),
        16usize,
        concat!("Size of: ", stringify!(_DIDDoc_ServicEndpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<_DIDDoc_ServicEndpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(_DIDDoc_ServicEndpoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc_ServicEndpoint>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc_ServicEndpoint),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc_ServicEndpoint>())).endpoint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc_ServicEndpoint),
            "::",
            stringify!(endpoint)
        )
    );
}
pub type DIDDoc_ServiceEndpoint = _DIDDoc_ServicEndpoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DIDDoc_Service {
    pub id: [::std::os::raw::c_char; 64usize],
    pub type_: *mut cJSON,
    pub endpoints: *mut cJSON,
}
#[test]
fn bindgen_test_layout__DIDDoc_Service() {
    assert_eq!(
        ::std::mem::size_of::<_DIDDoc_Service>(),
        80usize,
        concat!("Size of: ", stringify!(_DIDDoc_Service))
    );
    assert_eq!(
        ::std::mem::align_of::<_DIDDoc_Service>(),
        8usize,
        concat!("Alignment of ", stringify!(_DIDDoc_Service))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc_Service>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc_Service),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc_Service>())).type_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc_Service),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc_Service>())).endpoints as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc_Service),
            "::",
            stringify!(endpoints)
        )
    );
}
pub type DIDDoc_Service = _DIDDoc_Service;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DIDDoc_Services {
    pub Services: *mut cJSON,
}
#[test]
fn bindgen_test_layout__DIDDoc_Services() {
    assert_eq!(
        ::std::mem::size_of::<_DIDDoc_Services>(),
        8usize,
        concat!("Size of: ", stringify!(_DIDDoc_Services))
    );
    assert_eq!(
        ::std::mem::align_of::<_DIDDoc_Services>(),
        8usize,
        concat!("Alignment of ", stringify!(_DIDDoc_Services))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc_Services>())).Services as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc_Services),
            "::",
            stringify!(Services)
        )
    );
}
pub type DIDDoc_Services = _DIDDoc_Services;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DIDDoc {
    pub contexts: DIDDoc_Contexts,
    pub id: [::std::os::raw::c_char; 64usize],
    pub aka: DIDDoc_AlsoKnownAs,
    pub cons: DIDDoc_Controllers,
    pub vm: DIDDoc_VerificationMethod,
    pub auth: DIDDoc_VerificationMethod,
    pub assertion: DIDDoc_VerificationMethod,
    pub keyagreement: DIDDoc_VerificationMethod,
    pub ci: DIDDoc_VerificationMethod,
    pub cd: DIDDoc_VerificationMethod,
    pub publickey: DIDDoc_VerificationMethod,
    pub services: DIDDoc_Services,
    pub property_set: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__DIDDoc() {
    assert_eq!(
        ::std::mem::size_of::<_DIDDoc>(),
        216usize,
        concat!("Size of: ", stringify!(_DIDDoc))
    );
    assert_eq!(
        ::std::mem::align_of::<_DIDDoc>(),
        8usize,
        concat!("Alignment of ", stringify!(_DIDDoc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).contexts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(contexts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).aka as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(aka)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).cons as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(cons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).vm as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).auth as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(auth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).assertion as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(assertion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).keyagreement as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(keyagreement)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).ci as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(ci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).cd as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(cd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).publickey as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(publickey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).services as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(services)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DIDDoc>())).property_set as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_DIDDoc),
            "::",
            stringify!(property_set)
        )
    );
}
pub type DIDDoc = _DIDDoc;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VerificationMethod_Info {
    pub id: *mut ::std::os::raw::c_char,
    pub purpose: VerificationMethod_Purpose,
    pub type_: VerificationMethod_TypeValue,
    pub pubkey_type: VerificationMethod_PublicKeyType,
    pub pk_u: _VerificationMethod_Info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VerificationMethod_Info__bindgen_ty_1 {
    pub multibase: *mut ::std::os::raw::c_char,
    pub base58: *mut ::std::os::raw::c_char,
    pub jwk: *mut JWK,
}
#[test]
fn bindgen_test_layout__VerificationMethod_Info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_VerificationMethod_Info__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_VerificationMethod_Info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_VerificationMethod_Info__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_VerificationMethod_Info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VerificationMethod_Info__bindgen_ty_1>())).multibase as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerificationMethod_Info__bindgen_ty_1),
            "::",
            stringify!(multibase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VerificationMethod_Info__bindgen_ty_1>())).base58 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerificationMethod_Info__bindgen_ty_1),
            "::",
            stringify!(base58)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VerificationMethod_Info__bindgen_ty_1>())).jwk as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerificationMethod_Info__bindgen_ty_1),
            "::",
            stringify!(jwk)
        )
    );
}
#[test]
fn bindgen_test_layout__VerificationMethod_Info() {
    assert_eq!(
        ::std::mem::size_of::<_VerificationMethod_Info>(),
        32usize,
        concat!("Size of: ", stringify!(_VerificationMethod_Info))
    );
    assert_eq!(
        ::std::mem::align_of::<_VerificationMethod_Info>(),
        8usize,
        concat!("Alignment of ", stringify!(_VerificationMethod_Info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerificationMethod_Info>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerificationMethod_Info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VerificationMethod_Info>())).purpose as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerificationMethod_Info),
            "::",
            stringify!(purpose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerificationMethod_Info>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerificationMethod_Info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VerificationMethod_Info>())).pubkey_type as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerificationMethod_Info),
            "::",
            stringify!(pubkey_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerificationMethod_Info>())).pk_u as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerificationMethod_Info),
            "::",
            stringify!(pk_u)
        )
    );
}
pub type VerificationMethod_Info = _VerificationMethod_Info;
pub const RelativeDIDURLPath_Absolute: RelativeDIDURLPath = 0;
pub const RelativeDIDURLPath_NoScheme: RelativeDIDURLPath = 1;
pub const RelativeDIDURLPath_Empty: RelativeDIDURLPath = 2;
#[doc = ""]
pub type RelativeDIDURLPath = ::std::os::raw::c_uint;
pub const VerificationRelationship_VR_None: VerificationRelationship = 0;
pub const VerificationRelationship_AssertionMethod: VerificationRelationship = 1;
pub const VerificationRelationship_Authentication: VerificationRelationship = 2;
pub const VerificationRelationship_KeyAgreement: VerificationRelationship = 3;
pub const VerificationRelationship_ContractAgreement: VerificationRelationship = 4;
pub const VerificationRelationship_CapabilityInvocation: VerificationRelationship = 5;
pub const VerificationRelationship_CapabilityDelegation: VerificationRelationship = 6;
pub type VerificationRelationship = ::std::os::raw::c_uint;
pub const DIDsError_DIDERR_KeyMismatch: DIDsError = 0;
pub const DIDsError_DIDERR_MissingKey: DIDsError = 1;
pub const DIDsError_DIDERR_MultipleKeyMaterial: DIDsError = 2;
pub const DIDsError_DIDERR_DIDURL: DIDsError = 3;
pub const DIDsError_DIDERR_DIDURLDereference: DIDsError = 4;
pub const DIDsError_DIDERR_UnexpectedDIDFragment: DIDsError = 5;
pub const DIDsError_DIDERR_InvalidContext: DIDsError = 6;
pub const DIDsError_DIDERR_ControllerLimit: DIDsError = 7;
pub const DIDsError_DIDERR_MissingContext: DIDsError = 8;
pub const DIDsError_DIDERR_MissingDocumentId: DIDsError = 9;
pub const DIDsError_DIDERR_ExpectedObject: DIDsError = 10;
pub const DIDsError_DIDERR_UnsupportedVerificationRelationship: DIDsError = 11;
pub const DIDsError_DIDERR_ResourceNotFound: DIDsError = 12;
pub const DIDsError_DIDERR_ExpectedStringPublicKeyMultibase: DIDsError = 13;
pub const DIDsError_DIDERR_RepresentationNotSupported: DIDsError = 14;
pub const DIDsError_DIDERR_Multibase: DIDsError = 15;
pub const DIDsError_DIDERR_SerdeJSON: DIDsError = 16;
pub const DIDsError_DIDERR_SerdeUrlEncoded: DIDsError = 17;
pub const DIDsError_DIDERR_BlockchainAccountIdParse: DIDsError = 18;
pub const DIDsError_DIDERR_BlockchainAccountIdVerify: DIDsError = 19;
pub const DIDsError_DIDERR_FromHex: DIDsError = 20;
pub const DIDsError_DIDERR_Base58: DIDsError = 21;
pub const DIDsError_DIDERR_HexString: DIDsError = 22;
pub const DIDsError_DIDERR_UnableToResolve: DIDsError = 23;
pub const DIDsError_DIDERR_JWK: DIDsError = 24;
pub type DIDsError = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIDURL {
    pub did: *mut ::std::os::raw::c_char,
    pub path_abempty: *mut ::std::os::raw::c_char,
    pub query: *mut ::std::os::raw::c_char,
    pub fragment: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_DIDURL() {
    assert_eq!(
        ::std::mem::size_of::<DIDURL>(),
        32usize,
        concat!("Size of: ", stringify!(DIDURL))
    );
    assert_eq!(
        ::std::mem::align_of::<DIDURL>(),
        8usize,
        concat!("Alignment of ", stringify!(DIDURL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIDURL>())).did as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIDURL),
            "::",
            stringify!(did)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIDURL>())).path_abempty as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DIDURL),
            "::",
            stringify!(path_abempty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIDURL>())).query as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DIDURL),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIDURL>())).fragment as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DIDURL),
            "::",
            stringify!(fragment)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelativeDIDURL {
    pub type_: RelativeDIDURLPath,
    pub relative_didurl: *mut ::std::os::raw::c_char,
    pub query: *mut ::std::os::raw::c_char,
    pub fragment: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_RelativeDIDURL() {
    assert_eq!(
        ::std::mem::size_of::<RelativeDIDURL>(),
        32usize,
        concat!("Size of: ", stringify!(RelativeDIDURL))
    );
    assert_eq!(
        ::std::mem::align_of::<RelativeDIDURL>(),
        8usize,
        concat!("Alignment of ", stringify!(RelativeDIDURL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RelativeDIDURL>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RelativeDIDURL),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RelativeDIDURL>())).relative_didurl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RelativeDIDURL),
            "::",
            stringify!(relative_didurl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RelativeDIDURL>())).query as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RelativeDIDURL),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RelativeDIDURL>())).fragment as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RelativeDIDURL),
            "::",
            stringify!(fragment)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrimaryDIDURL {
    pub did: *mut ::std::os::raw::c_char,
    pub path: *mut ::std::os::raw::c_char,
    pub query: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PrimaryDIDURL() {
    assert_eq!(
        ::std::mem::size_of::<PrimaryDIDURL>(),
        24usize,
        concat!("Size of: ", stringify!(PrimaryDIDURL))
    );
    assert_eq!(
        ::std::mem::align_of::<PrimaryDIDURL>(),
        8usize,
        concat!("Alignment of ", stringify!(PrimaryDIDURL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PrimaryDIDURL>())).did as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PrimaryDIDURL),
            "::",
            stringify!(did)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PrimaryDIDURL>())).path as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PrimaryDIDURL),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PrimaryDIDURL>())).query as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PrimaryDIDURL),
            "::",
            stringify!(query)
        )
    );
}
pub type did_method_name =
    ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char>;
pub type did_method_generate =
    ::std::option::Option<unsafe extern "C" fn(jwk: *mut JWK) -> *mut ::std::os::raw::c_char>;
pub type did_method_from_transaction = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
pub type did_method_submit_transaction = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
pub type did_method_create = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
pub type did_method_update = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
pub type did_method_recover = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
pub type did_method_deactivate = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
pub type did_method_to_resolver =
    ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DID_Method {
    pub name: did_method_name,
    pub generate: did_method_generate,
    pub from_transaction: did_method_from_transaction,
    pub submit_transaction: did_method_submit_transaction,
    pub create: did_method_create,
    pub update: did_method_update,
    pub recover: did_method_recover,
    pub deactivate: did_method_deactivate,
    pub resolver: did_method_to_resolver,
}
#[test]
fn bindgen_test_layout_DID_Method() {
    assert_eq!(
        ::std::mem::size_of::<DID_Method>(),
        72usize,
        concat!("Size of: ", stringify!(DID_Method))
    );
    assert_eq!(
        ::std::mem::align_of::<DID_Method>(),
        8usize,
        concat!("Alignment of ", stringify!(DID_Method))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DID_Method>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DID_Method),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DID_Method>())).generate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DID_Method),
            "::",
            stringify!(generate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DID_Method>())).from_transaction as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DID_Method),
            "::",
            stringify!(from_transaction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DID_Method>())).submit_transaction as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DID_Method),
            "::",
            stringify!(submit_transaction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DID_Method>())).create as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DID_Method),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DID_Method>())).update as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DID_Method),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DID_Method>())).recover as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DID_Method),
            "::",
            stringify!(recover)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DID_Method>())).deactivate as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DID_Method),
            "::",
            stringify!(deactivate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DID_Method>())).resolver as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DID_Method),
            "::",
            stringify!(resolver)
        )
    );
}
extern "C" {
    pub fn get_verification_relationship_default() -> VerificationRelationship;
}
extern "C" {
    pub fn get_verification_relationship_from_str(
        str_: *mut ::std::os::raw::c_char,
    ) -> VerificationRelationship;
}
extern "C" {
    pub fn verification_relationship_to_str(
        ship: VerificationRelationship,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn verification_relationship_to_iri(
        ship: VerificationRelationship,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_did_generate(
        name: *mut ::std::os::raw::c_char,
        jwk: *mut JWK,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_diddoc_new() -> *mut DIDDoc;
}
extern "C" {
    pub fn iotex_diddoc_destroy(doc: *mut DIDDoc);
}
extern "C" {
    pub fn iotex_diddoc_verification_method_new(
        diddoc: *mut DIDDoc,
        purpose: VerificationMethod_Purpose,
        type_: VerificationMethod_Type,
    ) -> *mut DIDDoc_VerificationMethod;
}
extern "C" {
    pub fn iotex_diddoc_verification_method_map_new() -> VerificationMethod_Map;
}
extern "C" {
    pub fn iotex_diddoc_verification_method_map_set(
        map: VerificationMethod_Map,
        build_type: ::std::os::raw::c_uint,
        value: *mut ::std::os::raw::c_void,
    ) -> did_status_t;
}
extern "C" {
    pub fn iotex_diddoc_verification_method_set(
        vm: *mut DIDDoc_VerificationMethod,
        type_: VerificationMethod_Type,
        value: *mut ::std::os::raw::c_void,
    ) -> did_status_t;
}
extern "C" {
    pub fn iotex_diddoc_property_set(
        diddoc: *mut DIDDoc,
        build_type: ::std::os::raw::c_uint,
        name: *mut ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> did_status_t;
}
extern "C" {
    pub fn iotex_diddoc_service_endpoint_new(
        type_: ServiceEndpoint_type,
    ) -> *mut DIDDoc_ServiceEndpoint;
}
extern "C" {
    pub fn iotex_diddoc_service_new() -> *mut DIDDoc_Service;
}
extern "C" {
    pub fn iotex_diddoc_service_endpoint_set(
        ServiceEndpoint: *mut DIDDoc_ServiceEndpoint,
        type_: ServiceEndpoint_type,
        value: *mut ::std::os::raw::c_void,
    ) -> did_status_t;
}
extern "C" {
    pub fn iotex_diddoc_service_set(
        Service: *mut DIDDoc_Service,
        build_type: ::std::os::raw::c_uint,
        value: *mut ::std::os::raw::c_void,
    ) -> did_status_t;
}
extern "C" {
    pub fn iotex_diddoc_serialize(diddoc: *mut DIDDoc, format: bool)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_diddoc_parse(diddoc_serialize: *mut ::std::os::raw::c_char) -> *mut DIDDoc;
}
extern "C" {
    pub fn iotex_diddoc_verification_method_get_num(
        diddoc: *mut DIDDoc,
        purpose: VerificationMethod_Purpose,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn iotex_verification_method_info_destroy(info: *mut VerificationMethod_Info);
}
extern "C" {
    pub fn iotex_diddoc_verification_method_get(
        diddoc: *mut DIDDoc,
        purpose: VerificationMethod_Purpose,
        idx: ::std::os::raw::c_uint,
    ) -> *mut VerificationMethod_Info;
}
extern "C" {
    pub static mut did_io_method: DID_Method;
}
extern "C" {
    pub static mut did_key_method: DID_Method;
}
extern "C" {
    pub fn iotex_registry_item_register(
        kid: *mut ::std::os::raw::c_char,
        jwk: *mut JWK,
    ) -> did_status_t;
}
extern "C" {
    pub fn iotex_registry_item_unregister(kid: *mut ::std::os::raw::c_char) -> did_status_t;
}
extern "C" {
    pub fn iotex_registry_find_jwk_by_kid(kid: *mut ::std::os::raw::c_char) -> *mut JWK;
}
pub type vc_handle_t = ::std::os::raw::c_uint;
pub type property_handle_t = *mut cJSON;
pub const ProofSuiteType_DataIntegrityProof: ProofSuiteType = 0;
pub const ProofSuiteType_Ed25519Signature2020: ProofSuiteType = 1;
pub const ProofSuiteType_Ed25519Signature2018: ProofSuiteType = 2;
pub const ProofSuiteType_EcdsaSecp256k1Signature2019: ProofSuiteType = 3;
pub const ProofSuiteType_EcdsaSecp256r1Signature2019: ProofSuiteType = 4;
pub const ProofSuiteType_RsaSignature2018: ProofSuiteType = 5;
pub const ProofSuiteType_JsonWebSignature2020: ProofSuiteType = 6;
pub const ProofSuiteType_ProofSuiteTypeMax: ProofSuiteType = 7;
pub type ProofSuiteType = ::std::os::raw::c_uint;
pub const DataIntegrityCryptoSuite_Eddsa2022: DataIntegrityCryptoSuite = 0;
pub const DataIntegrityCryptoSuite_JcsEddsa2022: DataIntegrityCryptoSuite = 1;
pub const DataIntegrityCryptoSuite_Ecdsa2019: DataIntegrityCryptoSuite = 2;
pub const DataIntegrityCryptoSuite_JcsEcdsa2019: DataIntegrityCryptoSuite = 3;
pub const DataIntegrityCryptoSuite_DataIntegrityCryptoSuiteMax: DataIntegrityCryptoSuite = 4;
pub type DataIntegrityCryptoSuite = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_Contexts {
    pub contexts: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_Contexts() {
    assert_eq!(
        ::std::mem::size_of::<_VC_Contexts>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_Contexts))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_Contexts>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_Contexts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_Contexts>())).contexts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_Contexts),
            "::",
            stringify!(contexts)
        )
    );
}
pub type VC_Contexts = _VC_Contexts;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_Types {
    pub typs: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_Types() {
    assert_eq!(
        ::std::mem::size_of::<_VC_Types>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_Types))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_Types>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_Types))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_Types>())).typs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_Types),
            "::",
            stringify!(typs)
        )
    );
}
pub type VC_Types = _VC_Types;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_CredentialSubject {
    pub cs: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_CredentialSubject() {
    assert_eq!(
        ::std::mem::size_of::<_VC_CredentialSubject>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_CredentialSubject))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_CredentialSubject>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_CredentialSubject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_CredentialSubject>())).cs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_CredentialSubject),
            "::",
            stringify!(cs)
        )
    );
}
pub type VC_CredentialSubject = _VC_CredentialSubject;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_CredentialSubjects {
    pub css: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_CredentialSubjects() {
    assert_eq!(
        ::std::mem::size_of::<_VC_CredentialSubjects>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_CredentialSubjects))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_CredentialSubjects>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_CredentialSubjects))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_CredentialSubjects>())).css as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_CredentialSubjects),
            "::",
            stringify!(css)
        )
    );
}
pub type VC_CredentialSubjects = _VC_CredentialSubjects;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_Issuer {
    pub issuer: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_Issuer() {
    assert_eq!(
        ::std::mem::size_of::<_VC_Issuer>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_Issuer))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_Issuer>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_Issuer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_Issuer>())).issuer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_Issuer),
            "::",
            stringify!(issuer)
        )
    );
}
pub type VC_Issuer = _VC_Issuer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_Proof {
    pub proof: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_Proof() {
    assert_eq!(
        ::std::mem::size_of::<_VC_Proof>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_Proof))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_Proof>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_Proof))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_Proof>())).proof as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_Proof),
            "::",
            stringify!(proof)
        )
    );
}
pub type VC_Proof = _VC_Proof;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_Proofs {
    pub proofs: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_Proofs() {
    assert_eq!(
        ::std::mem::size_of::<_VC_Proofs>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_Proofs))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_Proofs>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_Proofs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_Proofs>())).proofs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_Proofs),
            "::",
            stringify!(proofs)
        )
    );
}
pub type VC_Proofs = _VC_Proofs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_Status {
    pub status: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_Status() {
    assert_eq!(
        ::std::mem::size_of::<_VC_Status>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_Status))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_Status>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_Status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_Status>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_Status),
            "::",
            stringify!(status)
        )
    );
}
pub type VC_Status = _VC_Status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_TermOfUse {
    pub termofuse: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_TermOfUse() {
    assert_eq!(
        ::std::mem::size_of::<_VC_TermOfUse>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_TermOfUse))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_TermOfUse>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_TermOfUse))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_TermOfUse>())).termofuse as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_TermOfUse),
            "::",
            stringify!(termofuse)
        )
    );
}
pub type VC_TermOfUse = _VC_TermOfUse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_TermsOfUse {
    pub termsofuse: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_TermsOfUse() {
    assert_eq!(
        ::std::mem::size_of::<_VC_TermsOfUse>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_TermsOfUse))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_TermsOfUse>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_TermsOfUse))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_TermsOfUse>())).termsofuse as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_TermsOfUse),
            "::",
            stringify!(termsofuse)
        )
    );
}
pub type VC_TermsOfUse = _VC_TermsOfUse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_Evidence {
    pub evidence: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_Evidence() {
    assert_eq!(
        ::std::mem::size_of::<_VC_Evidence>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_Evidence))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_Evidence>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_Evidence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_Evidence>())).evidence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_Evidence),
            "::",
            stringify!(evidence)
        )
    );
}
pub type VC_Evidence = _VC_Evidence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_Evidences {
    pub evidences: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_Evidences() {
    assert_eq!(
        ::std::mem::size_of::<_VC_Evidences>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_Evidences))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_Evidences>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_Evidences))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_Evidences>())).evidences as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_Evidences),
            "::",
            stringify!(evidences)
        )
    );
}
pub type VC_Evidences = _VC_Evidences;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_Schema {
    pub schema: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_Schema() {
    assert_eq!(
        ::std::mem::size_of::<_VC_Schema>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_Schema))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_Schema>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_Schema))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_Schema>())).schema as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_Schema),
            "::",
            stringify!(schema)
        )
    );
}
pub type VC_Schema = _VC_Schema;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_Schemas {
    pub schemas: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_Schemas() {
    assert_eq!(
        ::std::mem::size_of::<_VC_Schemas>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_Schemas))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_Schemas>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_Schemas))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_Schemas>())).schemas as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_Schemas),
            "::",
            stringify!(schemas)
        )
    );
}
pub type VC_Schemas = _VC_Schemas;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_RefreshService {
    pub rs: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_RefreshService() {
    assert_eq!(
        ::std::mem::size_of::<_VC_RefreshService>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_RefreshService))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_RefreshService>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_RefreshService))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_RefreshService>())).rs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_RefreshService),
            "::",
            stringify!(rs)
        )
    );
}
pub type VC_RefreshService = _VC_RefreshService;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VC_RefreshServices {
    pub rss: *mut cJSON,
}
#[test]
fn bindgen_test_layout__VC_RefreshServices() {
    assert_eq!(
        ::std::mem::size_of::<_VC_RefreshServices>(),
        8usize,
        concat!("Size of: ", stringify!(_VC_RefreshServices))
    );
    assert_eq!(
        ::std::mem::align_of::<_VC_RefreshServices>(),
        8usize,
        concat!("Alignment of ", stringify!(_VC_RefreshServices))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VC_RefreshServices>())).rss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VC_RefreshServices),
            "::",
            stringify!(rss)
        )
    );
}
pub type VC_RefreshServices = _VC_RefreshServices;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VerifiableCredential {
    pub contests: VC_Contexts,
    pub id: [::std::os::raw::c_char; 64usize],
    pub types: VC_Types,
    pub css: VC_CredentialSubjects,
    pub issuer: VC_Issuer,
    pub issuance_date: [::std::os::raw::c_char; 32usize],
    pub proofs: VC_Proofs,
    pub exp_date: [::std::os::raw::c_char; 64usize],
    pub status: VC_Status,
    pub terms_of_use: VC_TermsOfUse,
    pub evidences: VC_Evidences,
    pub schemas: VC_Schemas,
    pub refresh_services: VC_RefreshServices,
    pub property_set: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__VerifiableCredential() {
    assert_eq!(
        ::std::mem::size_of::<_VerifiableCredential>(),
        248usize,
        concat!("Size of: ", stringify!(_VerifiableCredential))
    );
    assert_eq!(
        ::std::mem::align_of::<_VerifiableCredential>(),
        8usize,
        concat!("Alignment of ", stringify!(_VerifiableCredential))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerifiableCredential>())).contests as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(contests)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerifiableCredential>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerifiableCredential>())).types as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerifiableCredential>())).css as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(css)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerifiableCredential>())).issuer as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VerifiableCredential>())).issuance_date as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(issuance_date)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerifiableCredential>())).proofs as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(proofs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerifiableCredential>())).exp_date as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(exp_date)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerifiableCredential>())).status as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VerifiableCredential>())).terms_of_use as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(terms_of_use)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerifiableCredential>())).evidences as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(evidences)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VerifiableCredential>())).schemas as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(schemas)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VerifiableCredential>())).refresh_services as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(refresh_services)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VerifiableCredential>())).property_set as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_VerifiableCredential),
            "::",
            stringify!(property_set)
        )
    );
}
pub type VerifiableCredential = _VerifiableCredential;
extern "C" {
    pub fn iotex_vc_new() -> vc_handle_t;
}
extern "C" {
    pub fn iotex_vc_destroy(handle: vc_handle_t) -> did_status_t;
}
extern "C" {
    pub fn iotex_vc_property_set(
        handle: vc_handle_t,
        build_type: ::std::os::raw::c_uint,
        name: *mut ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> did_status_t;
}
extern "C" {
    pub fn iotex_vc_property_get(
        vc_serialize: *mut ::std::os::raw::c_char,
        build_type: ::std::os::raw::c_uint,
        name: *mut ::std::os::raw::c_char,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn iotex_vc_sub_property_new() -> property_handle_t;
}
extern "C" {
    pub fn iotex_vc_sub_property_destroy(handle: property_handle_t) -> did_status_t;
}
extern "C" {
    pub fn iotex_vc_sub_property_set(
        handle: property_handle_t,
        build_type: ::std::os::raw::c_uint,
        name: *mut ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> did_status_t;
}
extern "C" {
    pub fn iotex_get_proof_suite_type_string(type_: ProofSuiteType) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_get_data_intergrity_cryptosuite_string(
        type_: DataIntegrityCryptoSuite,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_vc_serialize(handle: vc_handle_t, format: bool) -> *mut ::std::os::raw::c_char;
}
#[doc = " AES256-CBC + HMAC-SHA512 with a 512 bit key content encryption,"]
#[doc = " ECDH-1PU key agreement with A256KW key wrapping"]
pub const AuthCryptAlg_A256cbcHs512Ecdh1puA256kw: AuthCryptAlg = 0;
pub type AuthCryptAlg = ::std::os::raw::c_uint;
#[doc = " AES256-CBC + HMAC-SHA512 with a 512 bit key content encryption,"]
#[doc = " ECDH-ES key agreement with A256KW key wrapping"]
pub const AnonCryptAlg_A256cbcHs512EcdhEsA256kw: AnonCryptAlg = 0;
#[doc = " XChaCha20Poly1305 with a 256 bit key content encryption,"]
#[doc = " ECDH-ES key agreement with A256KW key wrapping"]
pub const AnonCryptAlg_Xc20pEcdhEsA256kw: AnonCryptAlg = 1;
#[doc = " A256GCM_ECDH_ES_A256KW: XChaCha20Poly1305 with a 256 bit key content encryption,"]
#[doc = " ECDH-ES key agreement with A256KW key wrapping"]
pub const AnonCryptAlg_A256gcmEcdhEsA256kw: AnonCryptAlg = 2;
pub type AnonCryptAlg = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MessagingServiceMetadata {
    #[doc = " Identifier (DID URL) of used messaging service."]
    pub id: *mut ::std::os::raw::c_char,
    #[doc = " Service endpoint of used messaging service."]
    pub service_endpoint: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__MessagingServiceMetadata() {
    assert_eq!(
        ::std::mem::size_of::<_MessagingServiceMetadata>(),
        16usize,
        concat!("Size of: ", stringify!(_MessagingServiceMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<_MessagingServiceMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(_MessagingServiceMetadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MessagingServiceMetadata>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MessagingServiceMetadata),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MessagingServiceMetadata>())).service_endpoint as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MessagingServiceMetadata),
            "::",
            stringify!(service_endpoint)
        )
    );
}
pub type MessagingServiceMetadata = _MessagingServiceMetadata;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PackEncryptedMetadata {
    #[doc = " Information about messaging service used for message preparation."]
    #[doc = " Practically `service_endpoint` field can be used to transport the message."]
    pub messaging_service: *mut MessagingServiceMetadata,
    #[doc = " Identifier (DID URL) of sender key used for message encryption."]
    pub from_kid: *mut ::std::os::raw::c_char,
    #[doc = " Identifier (DID URL) of sender key used for message sign."]
    pub sign_by_kid: *mut ::std::os::raw::c_char,
    #[doc = " Identifiers (DID URLs) of recipient keys used for message encryption."]
    pub to_kid_num: ::std::os::raw::c_uint,
    pub to_kids: [*mut ::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout__PackEncryptedMetadata() {
    assert_eq!(
        ::std::mem::size_of::<_PackEncryptedMetadata>(),
        64usize,
        concat!("Size of: ", stringify!(_PackEncryptedMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<_PackEncryptedMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(_PackEncryptedMetadata))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PackEncryptedMetadata>())).messaging_service as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PackEncryptedMetadata),
            "::",
            stringify!(messaging_service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PackEncryptedMetadata>())).from_kid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PackEncryptedMetadata),
            "::",
            stringify!(from_kid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PackEncryptedMetadata>())).sign_by_kid as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PackEncryptedMetadata),
            "::",
            stringify!(sign_by_kid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PackEncryptedMetadata>())).to_kid_num as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PackEncryptedMetadata),
            "::",
            stringify!(to_kid_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PackEncryptedMetadata>())).to_kids as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PackEncryptedMetadata),
            "::",
            stringify!(to_kids)
        )
    );
}
pub type PackEncryptedMetadata = _PackEncryptedMetadata;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PackEncryptedOptions {
    #[doc = " If `true` and message is authenticated than information about sender will be protected from mediators, but"]
    #[doc = " additional re-encryption will be required. For anonymous messages this property will be ignored."]
    pub protect_sender: bool,
    #[doc = " Whether the encrypted messages need to be wrapped into `Forward` messages to be sent to Mediators"]
    #[doc = " as defined by the `Forward` protocol."]
    pub forward: bool,
    #[doc = " if forward is enabled these optional headers can be passed to the wrapping `Forward` messages."]
    #[doc = " If forward is disabled this property will be ignored."]
    pub forward_headers: *mut ::std::os::raw::c_void,
    #[doc = " Identifier (DID URL) of messaging service (https://identity.foundation/didcomm-messaging/spec/#did-document-service-endpoint)."]
    #[doc = " If DID doc contains multiple messaging services it allows specify what service to use."]
    #[doc = " If not present first service will be used."]
    pub messaging_service: *mut ::std::os::raw::c_char,
    #[doc = " Algorithm used for authenticated encryption"]
    pub enc_alg_auth: AuthCryptAlg,
    #[doc = " Algorithm used for anonymous encryption"]
    pub enc_alg_anon: AnonCryptAlg,
}
#[test]
fn bindgen_test_layout__PackEncryptedOptions() {
    assert_eq!(
        ::std::mem::size_of::<_PackEncryptedOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_PackEncryptedOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_PackEncryptedOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_PackEncryptedOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PackEncryptedOptions>())).protect_sender as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PackEncryptedOptions),
            "::",
            stringify!(protect_sender)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PackEncryptedOptions>())).forward as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_PackEncryptedOptions),
            "::",
            stringify!(forward)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PackEncryptedOptions>())).forward_headers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PackEncryptedOptions),
            "::",
            stringify!(forward_headers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PackEncryptedOptions>())).messaging_service as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PackEncryptedOptions),
            "::",
            stringify!(messaging_service)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PackEncryptedOptions>())).enc_alg_auth as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PackEncryptedOptions),
            "::",
            stringify!(enc_alg_auth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PackEncryptedOptions>())).enc_alg_anon as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PackEncryptedOptions),
            "::",
            stringify!(enc_alg_anon)
        )
    );
}
pub type PackEncryptedOptions = _PackEncryptedOptions;
pub const Envelope_Algorithm_ENVELOPE_EdDSA: Envelope_Algorithm = 0;
pub const Envelope_Algorithm_ENVELOPE_Es256: Envelope_Algorithm = 1;
pub const Envelope_Algorithm_ENVELOPE_Es256K: Envelope_Algorithm = 2;
pub const Envelope_Algorithm_ENVELOPE_Other: Envelope_Algorithm = 3;
pub type Envelope_Algorithm = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FromPrior {
    pub iss: *mut ::std::os::raw::c_char,
    pub sub: *mut ::std::os::raw::c_char,
    pub aud: *mut ::std::os::raw::c_char,
    pub exp: time_t,
    pub nbf: time_t,
    pub iat: time_t,
    pub jti: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__FromPrior() {
    assert_eq!(
        ::std::mem::size_of::<_FromPrior>(),
        56usize,
        concat!("Size of: ", stringify!(_FromPrior))
    );
    assert_eq!(
        ::std::mem::align_of::<_FromPrior>(),
        8usize,
        concat!("Alignment of ", stringify!(_FromPrior))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FromPrior>())).iss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FromPrior),
            "::",
            stringify!(iss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FromPrior>())).sub as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FromPrior),
            "::",
            stringify!(sub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FromPrior>())).aud as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FromPrior),
            "::",
            stringify!(aud)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FromPrior>())).exp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FromPrior),
            "::",
            stringify!(exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FromPrior>())).nbf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FromPrior),
            "::",
            stringify!(nbf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FromPrior>())).iat as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FromPrior),
            "::",
            stringify!(iat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FromPrior>())).jti as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FromPrior),
            "::",
            stringify!(jti)
        )
    );
}
pub type FromPrior = _FromPrior;
extern "C" {
    pub fn fromprior_new(
        iss: *mut ::std::os::raw::c_char,
        sub: *mut ::std::os::raw::c_char,
    ) -> *mut FromPrior;
}
extern "C" {
    pub fn fromprior_set_aud(
        fromprior: *mut FromPrior,
        aud: *mut ::std::os::raw::c_char,
    ) -> *mut FromPrior;
}
extern "C" {
    pub fn fromprior_set_exp(fromprior: *mut FromPrior, exp: time_t) -> *mut FromPrior;
}
extern "C" {
    pub fn fromprior_set_nbf(fromprior: *mut FromPrior, nbf: time_t) -> *mut FromPrior;
}
extern "C" {
    pub fn fromprior_set_iat(fromprior: *mut FromPrior, iat: time_t) -> *mut FromPrior;
}
extern "C" {
    pub fn fromprior_set_jti(
        fromprior: *mut FromPrior,
        jti: *mut ::std::os::raw::c_char,
    ) -> *mut FromPrior;
}
pub const _AttachmentData_Type_AttachmentData_Base64: _AttachmentData_Type = 0;
pub const _AttachmentData_Type_AttachmentData_Json: _AttachmentData_Type = 1;
pub const _AttachmentData_Type_AttachmentData_Links: _AttachmentData_Type = 2;
pub type _AttachmentData_Type = ::std::os::raw::c_uint;
pub use self::_AttachmentData_Type as AttachmentData_Type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Base64AttachmentData {
    #[doc = " Base64-encoded data, when representing arbitrary content inline."]
    pub base64: *mut ::std::os::raw::c_char,
    #[doc = " A JSON Web Signature over the content of the attachment."]
    pub jws: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__Base64AttachmentData() {
    assert_eq!(
        ::std::mem::size_of::<_Base64AttachmentData>(),
        16usize,
        concat!("Size of: ", stringify!(_Base64AttachmentData))
    );
    assert_eq!(
        ::std::mem::align_of::<_Base64AttachmentData>(),
        8usize,
        concat!("Alignment of ", stringify!(_Base64AttachmentData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Base64AttachmentData>())).base64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Base64AttachmentData),
            "::",
            stringify!(base64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Base64AttachmentData>())).jws as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Base64AttachmentData),
            "::",
            stringify!(jws)
        )
    );
}
pub type Base64AttachmentData = _Base64AttachmentData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JsonAttachmentData {
    #[doc = " Directly embedded JSON data."]
    pub json_type: ::std::os::raw::c_uint,
    pub json: *mut ::std::os::raw::c_void,
    #[doc = " A JSON Web Signature over the content of the attachment."]
    pub jws: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__JsonAttachmentData() {
    assert_eq!(
        ::std::mem::size_of::<_JsonAttachmentData>(),
        24usize,
        concat!("Size of: ", stringify!(_JsonAttachmentData))
    );
    assert_eq!(
        ::std::mem::align_of::<_JsonAttachmentData>(),
        8usize,
        concat!("Alignment of ", stringify!(_JsonAttachmentData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JsonAttachmentData>())).json_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JsonAttachmentData),
            "::",
            stringify!(json_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JsonAttachmentData>())).json as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JsonAttachmentData),
            "::",
            stringify!(json)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JsonAttachmentData>())).jws as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JsonAttachmentData),
            "::",
            stringify!(jws)
        )
    );
}
pub type JsonAttachmentData = _JsonAttachmentData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LinksAttachmentData {
    #[doc = " A list of one or more locations at which the content may be fetched."]
    pub links: [*mut ::std::os::raw::c_char; 4usize],
    #[doc = " The hash of the content encoded in multi-hash format. Used as an integrity check for the attachment."]
    pub hash: *mut ::std::os::raw::c_char,
    #[doc = " A JSON Web Signature over the content of the attachment."]
    pub jws: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__LinksAttachmentData() {
    assert_eq!(
        ::std::mem::size_of::<_LinksAttachmentData>(),
        48usize,
        concat!("Size of: ", stringify!(_LinksAttachmentData))
    );
    assert_eq!(
        ::std::mem::align_of::<_LinksAttachmentData>(),
        8usize,
        concat!("Alignment of ", stringify!(_LinksAttachmentData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LinksAttachmentData>())).links as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LinksAttachmentData),
            "::",
            stringify!(links)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LinksAttachmentData>())).hash as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_LinksAttachmentData),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LinksAttachmentData>())).jws as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_LinksAttachmentData),
            "::",
            stringify!(jws)
        )
    );
}
pub type LinksAttachmentData = _LinksAttachmentData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _AttachmentData {
    pub type_: AttachmentData_Type,
    pub data: _AttachmentData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _AttachmentData__bindgen_ty_1 {
    pub base64_data: Base64AttachmentData,
    pub json_data: JsonAttachmentData,
    pub link_data: LinksAttachmentData,
}
#[test]
fn bindgen_test_layout__AttachmentData__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_AttachmentData__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(_AttachmentData__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_AttachmentData__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_AttachmentData__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_AttachmentData__bindgen_ty_1>())).base64_data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AttachmentData__bindgen_ty_1),
            "::",
            stringify!(base64_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_AttachmentData__bindgen_ty_1>())).json_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AttachmentData__bindgen_ty_1),
            "::",
            stringify!(json_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_AttachmentData__bindgen_ty_1>())).link_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AttachmentData__bindgen_ty_1),
            "::",
            stringify!(link_data)
        )
    );
}
#[test]
fn bindgen_test_layout__AttachmentData() {
    assert_eq!(
        ::std::mem::size_of::<_AttachmentData>(),
        56usize,
        concat!("Size of: ", stringify!(_AttachmentData))
    );
    assert_eq!(
        ::std::mem::align_of::<_AttachmentData>(),
        8usize,
        concat!("Alignment of ", stringify!(_AttachmentData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_AttachmentData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AttachmentData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_AttachmentData>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_AttachmentData),
            "::",
            stringify!(data)
        )
    );
}
pub type AttachmentData = _AttachmentData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _attachment {
    #[doc = " A JSON object that gives access to the actual content of the attachment."]
    #[doc = " Can be based on base64, json or external links."]
    pub data: AttachmentData,
    #[doc = " Identifies attached content within the scope of a given message."]
    #[doc = "  Recommended on appended attachment descriptors. Possible but generally unused"]
    #[doc = "  on embedded attachment descriptors. Never required if no references to the attachment"]
    #[doc = "  exist; if omitted, then there is no way to refer to the attachment later in the thread,"]
    #[doc = "  in error messages, and so forth. Because id is used to compose URIs, it is recommended"]
    #[doc = "  that this name be brief and avoid spaces and other characters that require URI escaping."]
    pub id: *mut ::std::os::raw::c_char,
    #[doc = " A human-readable description of the content."]
    pub description: *mut ::std::os::raw::c_char,
    #[doc = " A hint about the name that might be used if this attachment is persisted as a file."]
    #[doc = " It is not required, and need not be unique. If this field is present and mime-type is not,"]
    #[doc = " the extension on the filename may be used to infer a MIME type."]
    pub filename: *mut ::std::os::raw::c_char,
    #[doc = " Describes the MIME type of the attached content."]
    pub media_type: *mut ::std::os::raw::c_char,
    #[doc = " Describes the format of the attachment if the mime_type is not sufficient."]
    pub format: *mut ::std::os::raw::c_char,
    #[doc = " A hint about when the content in this attachment was last modified"]
    #[doc = " in UTC Epoch Seconds (seconds since 1970-01-01T00:00:00Z UTC)."]
    pub lastmod_time: time_t,
    #[doc = " Mostly relevant when content is included by reference instead of by value."]
    #[doc = " Lets the receiver guess how expensive it will be, in time, bandwidth, and storage,"]
    #[doc = " to fully fetch the attachment."]
    pub byte_count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__attachment() {
    assert_eq!(
        ::std::mem::size_of::<_attachment>(),
        112usize,
        concat!("Size of: ", stringify!(_attachment))
    );
    assert_eq!(
        ::std::mem::align_of::<_attachment>(),
        8usize,
        concat!("Alignment of ", stringify!(_attachment))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_attachment>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_attachment),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_attachment>())).id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_attachment),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_attachment>())).description as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_attachment),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_attachment>())).filename as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_attachment),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_attachment>())).media_type as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_attachment),
            "::",
            stringify!(media_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_attachment>())).format as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_attachment),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_attachment>())).lastmod_time as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_attachment),
            "::",
            stringify!(lastmod_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_attachment>())).byte_count as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_attachment),
            "::",
            stringify!(byte_count)
        )
    );
}
pub type Attachment = _attachment;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _message {
    #[doc = " Message id. Must be unique to the sender."]
    pub id: *mut ::std::os::raw::c_char,
    #[doc = " Optional, if present it must be \"application/didcomm-plain+json\""]
    pub typ: *mut ::std::os::raw::c_char,
    #[doc = " Message type attribute value MUST be a valid Message Type URI,"]
    #[doc = " that when resolved gives human readable information about the message."]
    #[doc = " The attribute’s value also informs the content of the message,"]
    #[doc = " or example the presence of other attributes and how they should be processed."]
    pub type_: *mut ::std::os::raw::c_char,
    pub body_type: ::std::os::raw::c_uint,
    #[doc = " Message body."]
    pub body: *mut ::std::os::raw::c_void,
    #[doc = " Sender identifier. The from attribute MUST be a string that is a valid DID"]
    #[doc = " or DID URL (without the fragment component) which identifies the sender of the message."]
    pub from: *mut ::std::os::raw::c_char,
    #[doc = " Identifier(s) for recipients. MUST be an array of strings where each element"]
    #[doc = " is a valid DID or DID URL (without the fragment component) that identifies a member"]
    #[doc = " of the message’s intended audience."]
    pub to: [*mut ::std::os::raw::c_char; 4usize],
    #[doc = " Uniquely identifies the thread that the message belongs to."]
    #[doc = " If not included the id property of the message MUST be treated as the value of the `thid`."]
    pub thid: *mut ::std::os::raw::c_char,
    #[doc = " If the message is a child of a thread the `pthid`"]
    #[doc = " will uniquely identify which thread is the parent."]
    pub pthid: *mut ::std::os::raw::c_char,
    #[doc = " Custom message headers. HashMap<String, Value>"]
    pub extra_headers: *mut ::std::os::raw::c_void,
    #[doc = " The attribute is used for the sender"]
    #[doc = " to express when they created the message, expressed in"]
    #[doc = " UTC Epoch Seconds (seconds since 1970-01-01T00:00:00Z UTC)."]
    #[doc = " This attribute is informative to the recipient, and may be relied on by protocols."]
    pub created_time: time_t,
    #[doc = " The expires_time attribute is used for the sender to express when they consider"]
    #[doc = " the message to be expired, expressed in UTC Epoch Seconds (seconds since 1970-01-01T00:00:00Z UTC)."]
    #[doc = " This attribute signals when the message is considered no longer valid by the sender."]
    #[doc = " When omitted, the message is considered to have no expiration by the sender."]
    pub expires_time: time_t,
    #[doc = " from_prior is a compactly serialized signed JWT containing FromPrior value"]
    pub from_prior: *mut ::std::os::raw::c_char,
    #[doc = " Message attachments"]
    pub attachments: [*mut Attachment; 4usize],
}
#[test]
fn bindgen_test_layout__message() {
    assert_eq!(
        ::std::mem::size_of::<_message>(),
        160usize,
        concat!("Size of: ", stringify!(_message))
    );
    assert_eq!(
        ::std::mem::align_of::<_message>(),
        8usize,
        concat!("Alignment of ", stringify!(_message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).typ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(typ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).body_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(body_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).body as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).from as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).to as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).thid as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(thid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).pthid as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(pthid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).extra_headers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(extra_headers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).created_time as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(created_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).expires_time as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(expires_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).from_prior as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(from_prior)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_message>())).attachments as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_message),
            "::",
            stringify!(attachments)
        )
    );
}
pub type Message = _message;
extern "C" {
    pub fn attachment_new(data: *mut AttachmentData) -> *mut Attachment;
}
extern "C" {
    pub fn attachment_set_id(
        attachment: *mut Attachment,
        id: *mut ::std::os::raw::c_char,
    ) -> *mut Attachment;
}
extern "C" {
    pub fn attachment_set_description(
        attachment: *mut Attachment,
        description: *mut ::std::os::raw::c_char,
    ) -> *mut Attachment;
}
extern "C" {
    pub fn attachment_set_filename(
        attachment: *mut Attachment,
        filename: *mut ::std::os::raw::c_char,
    ) -> *mut Attachment;
}
extern "C" {
    pub fn attachment_set_media_type(
        attachment: *mut Attachment,
        media_type: *mut ::std::os::raw::c_char,
    ) -> *mut Attachment;
}
extern "C" {
    pub fn attachment_set_format(
        attachment: *mut Attachment,
        format: *mut ::std::os::raw::c_char,
    ) -> *mut Attachment;
}
extern "C" {
    pub fn attachment_set_lastmod_time(
        attachment: *mut Attachment,
        lastmod_time: time_t,
    ) -> *mut Attachment;
}
extern "C" {
    pub fn attachment_set_byte_count(
        attachment: *mut Attachment,
        byte_count: ::std::os::raw::c_uint,
    ) -> *mut Attachment;
}
extern "C" {
    pub fn attachmentdata_new_base64(base64: *mut ::std::os::raw::c_char) -> *mut AttachmentData;
}
extern "C" {
    pub fn attachmentdata_new_json(
        json_type: ::std::os::raw::c_uint,
        json: *mut ::std::os::raw::c_void,
    ) -> *mut AttachmentData;
}
extern "C" {
    pub fn message_new(
        id: *mut ::std::os::raw::c_char,
        type_: *mut ::std::os::raw::c_char,
        body_type: ::std::os::raw::c_uint,
        body: *mut ::std::os::raw::c_void,
    ) -> *mut Message;
}
extern "C" {
    pub fn message_set_to(message: *mut Message, to: *mut ::std::os::raw::c_char) -> *mut Message;
}
extern "C" {
    pub fn message_set_from(
        message: *mut Message,
        from: *mut ::std::os::raw::c_char,
    ) -> *mut Message;
}
extern "C" {
    pub fn message_set_thid(
        message: *mut Message,
        thid: *mut ::std::os::raw::c_char,
    ) -> *mut Message;
}
extern "C" {
    pub fn message_set_pthid(
        message: *mut Message,
        pthid: *mut ::std::os::raw::c_char,
    ) -> *mut Message;
}
extern "C" {
    pub fn message_set_created_time(message: *mut Message, created_time: time_t) -> *mut Message;
}
extern "C" {
    pub fn message_set_expires_time(message: *mut Message, expires_time: time_t) -> *mut Message;
}
extern "C" {
    pub fn message_set_from_prior(
        message: *mut Message,
        from_prior: *mut ::std::os::raw::c_char,
    ) -> *mut Message;
}
extern "C" {
    pub fn message_set_attachment(
        message: *mut Message,
        attachment: *mut Attachment,
    ) -> *mut Message;
}
extern "C" {
    pub fn didcomm_message_pack_plaintext(message: *mut Message) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn didcomm_message_pack_signed(
        message: *mut Message,
        sign_by: *mut ::std::os::raw::c_char,
        jwk: *mut JWK,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn didcomm_message_pack_encrypted(
        message: *mut Message,
        from: *mut ::std::os::raw::c_char,
        to: *mut ::std::os::raw::c_char,
        sign_by: *mut ::std::os::raw::c_char,
        option: *mut PackEncryptedOptions,
        jwk: *mut JWK,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn iotex_deviceconnect_sdk_core_init(
        get_time_func: iotex_gettime,
        mqtt_pub: iotex_mqtt_pub,
        mqtt_sub: iotex_mqtt_sub,
    ) -> *mut u8;
}
extern "C" {
    pub fn iotex_deviceconnect_sdk_core_get_public_key() -> *mut u8;
}
extern "C" {
    pub fn iotex_deviceconnect_sdk_core_get_eth_addr() -> *mut u8;
}
extern "C" {
    pub fn iotex_ioconnect_core_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
